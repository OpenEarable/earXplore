<!-- Include D3.js -->
<script src="https://d3js.org/d3.v7.min.js"></script>

<style>
    #timeline-container {
        background: #f8f9fa;
        border-radius: 8px;
        padding: 20px;
        box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1);
        margin: 20px 0;
    }
    
    .timeline-controls {
        margin-bottom: 20px;
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        gap: 15px;
    }
    
    .timeline-node {
        cursor: pointer;
    }
    
    .timeline-link {
        stroke-opacity: 0.6;
        fill: none;
    }
    
    .timeline-node-label {
        font-size: 10px;
        pointer-events: none;
    }
    
    .timeline-tooltip {
        position: absolute;
        background: white;
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 8px;
        pointer-events: none;
        box-shadow: 0px 0px 5px rgba(0, 0, 0, 0.2);
        z-index: 1000;
    }
    
    /* Button styling to match site theme */
    .btn-timeline {
        background-color: #B89491;
        border-color: #B89491;
        color: white;
    }
    
    .btn-timeline:hover {
        background-color: #a37c79;
        border-color: #a37c79;
    }
    
    .btn-timeline:not(.active) {
        background-color: white;
        color: #666;
        border-color: #B89491;
    }
    
    /* Timeline axis styling */
    .timeline-axis {
        stroke: #ccc;
        stroke-width: 2;
    }
    
    .timeline-tick {
        stroke: #ccc;
        stroke-width: 1;
    }
    
    .timeline-label {
        font-size: 12px;
        fill: #666;
    }
    
    /* Container dimensions */
    #timeline-graph-container {
        width: 100%;
        height: 600px;
        border: 1px solid #ddd;
        border-radius: 5px;
        overflow: visible;
        margin-bottom: 20px;
    }
    
    .timeline-info-icon {
        cursor: pointer;
        transition: transform 0.2s ease, fill 0.2s ease;
    }
    
    .timeline-info-icon:hover {
        fill: #a37c79 !important;
        transform: scale(1.2);
    }
    
    /* Connection type styles */
    .timeline-link-cites, .timeline-link-cited-by {
        stroke: #999;  /* Use neutral gray like in similarity.html */
    }
    
    .timeline-link-author {
        stroke: #999;  /* Same neutral color */
        stroke-dasharray: 5,3;  /* Keep the dashed style for author links */
    }

    /* Hover styles */
    .timeline-link.highlighted {
        stroke: #B89491 !important;  /* Match the color used in similarity.html */
        stroke-opacity: 1 !important;
        stroke-width: 2 !important;
    }
    
    /* Legend styling */
    .timeline-legend {
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
        margin-top: 10px;
    }
    
    .timeline-legend-item {
        display: flex;
        align-items: center;
        font-size: 12px;
    }
    
    .timeline-legend-color {
        width: 20px;
        height: 3px;
        margin-right: 5px;
    }
    
    .timeline-no-data-message {
        text-align: center;
        padding: 40px;
        color: #721c24;
        font-size: 16px;
    }

    .timeline-legend-line {
        display: flex;
        align-items: center;
        margin-right: 5px;
    }
    
    /* Remove this old style since we're not using color blocks anymore */
    .timeline-legend-color {
        width: 20px;
        height: 3px;
        margin-right: 5px;
    }

    .connections-container h5 {
        margin-bottom: 15px;
        color: #B89491;
    }

    .connections-container .table {
        font-size: 14px;
        table-layout: fixed;
        width: 100%;
    }

    .connections-container .table th {
        background-color: #f8f9fa;
        font-size: 14px;
    }

    .connections-container .table td {
        font-size: 14px;
        vertical-align: middle;
    }

    .table-responsive {
        margin-bottom: 1.5rem;
    }

    .view-study-details:hover {
        color: #a37c79;
    }

    .selected-study-row {
        background-color: #e2f0fb !important;
    }
</style>

<div id="timeline-container">
    <div class="timeline-controls">
        <div>
            <strong>Shared Authors:</strong>
            <div class="form-check form-switch ms-2 d-inline-block">
                <input class="form-check-input" type="checkbox" id="timeline-toggle-shared-authors" checked>
                <label class="form-check-label" for="timeline-toggle-shared-authors"></label>
            </div>
        </div>
        
        <div class="mt-2">
            <strong>Citation Mode:</strong>
            <div class="btn-group ms-2" role="group" aria-label="Citation mode selection">
                <input type="radio" class="btn-check" name="citation-mode" id="timeline-mode-both" autocomplete="off" checked>
                <label class="btn btn-sm btn-timeline" for="timeline-mode-both">Both</label>
                
                <input type="radio" class="btn-check" name="citation-mode" id="timeline-mode-cites" autocomplete="off">
                <label class="btn btn-sm btn-timeline" for="timeline-mode-cites">Cites</label>
                
                <input type="radio" class="btn-check" name="citation-mode" id="timeline-mode-cited-by" autocomplete="off">
                <label class="btn btn-sm btn-timeline" for="timeline-mode-cited-by">Cited By</label>
                
                <input type="radio" class="btn-check" name="citation-mode" id="timeline-mode-none" autocomplete="off">
                <label class="btn btn-sm btn-timeline" for="timeline-mode-none">None</label>
            </div>
        </div>
        
        <div class="timeline-legend">
            <div class="timeline-legend-item">
                <div class="timeline-legend-line">
                    <svg width="20" height="3">
                        <line x1="0" y1="1.5" x2="20" y2="1.5" stroke="#999" stroke-width="3" stroke-dasharray="5,3"/>
                    </svg>
                </div>
                <span>Shared Authors</span>
            </div>
            <div class="timeline-legend-item">
                <div class="timeline-legend-line">
                    <svg width="20" height="3">
                        <line x1="0" y1="1.5" x2="20" y2="1.5" stroke="#999" stroke-width="3"/>
                    </svg>
                </div>
                <span>Citations</span>
            </div>
            <div class="timeline-legend-item">
                <div class="timeline-legend-line">
                    <svg width="20" height="3">
                        <line x1="0" y1="1.5" x2="20" y2="1.5" stroke="#B89491" stroke-width="3"/>
                    </svg>
                </div>
                <span>Highlighted</span>
            </div>
        </div>

        <div class="category-dropdown-container">
            <label for="timelineColorCategory" style="margin-bottom: 12px; display: block;">
                <strong>Color Nodes by:</strong>
            </label>
            <select id="timelineColorCategory" class="form-select" style="width: 200px;">
                <option value="">None</option>
                <!-- Category options will be populated dynamically -->
            </select>
        </div>
    </div>
    
    <div id="timeline-graph-container"></div>

    <div class="modal fade" id="timelineConnectionsModal" tabindex="-1" aria-labelledby="connectionsModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-body">
                    <div id="timelineConnectionsContainer">
                        <!-- Connected studies will be populated here -->
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
// Use an immediately invoked function expression (IIFE) to create a closure and avoid polluting the global namespace
(function() {
    // Timeline-specific variables with proper namespacing
    let timelineSvg;
    let timelineWidth, timelineHeight;
    let timelineTooltip;
    let timelineConnectionsModal;
    let timelineStudyData = [];
    let timelineYearGroups = {};
    let timelineStudyIdToIndex = {};
    let timelineCitationMatrix = [];
    let timelineCoauthorMatrix = [];
    let nodeById = {}; // Add this line to create a shared variable
    let timelineCurrentColorScale = null; // To store the current color scale for the timeline
    
    // Connection visibility flags
    let timelineShowSharedAuthors = true;
    let timelineCitationMode = "both"; // "both", "cites", or "cited-by"
    
    // Constants
    const TIMELINE_NODE_RADIUS = 8;
    const TIMELINE_NODE_SPACING = 25;
    const TIMELINE_PADDING = 60;
    
    // Add these variables to the top of your script, inside the IIFE
    let timelineRawCitationMatrix = [];
    let timelineRawCoauthorMatrix = [];
    let timelineCitationIds = [];
    let timelineCoauthorIds = [];
    let timelineIdMapping = {};
    let timelineColorScaleCache = {};

    // Debugging function to inspect matrices
    function debugMatrix(matrix, label) {
        console.log(`----- DEBUG: ${label} -----`);
        console.log(`Matrix dimensions: ${matrix.length} rows`);
        
        if (matrix.length > 0) {
            console.log(`First row length: ${matrix[0].length}`);
            console.log(`First row content:`, matrix[0]);
            
            if (matrix.length > 1) {
                console.log(`Second row example:`, matrix[1].slice(0, 10));
                // Look for any non-zero values
                let hasConnections = false;
                let firstNonZeroRow = -1;
                let firstNonZeroCol = -1;
                
                for (let i = 1; i < Math.min(matrix.length, 10); i++) {
                    for (let j = 1; j < Math.min(matrix[i].length, 10); j++) {
                        if (matrix[i][j] === 1 || matrix[i][j] === "1") {
                            hasConnections = true;
                            firstNonZeroRow = i;
                            firstNonZeroCol = j;
                            break;
                        }
                    }
                    if (hasConnections) break;
                }
                
                if (hasConnections) {
                    console.log(`Found connection at [${firstNonZeroRow}][${firstNonZeroCol}]: Source=${matrix[firstNonZeroRow][0]}, Target=${matrix[0][firstNonZeroCol]}`);
                } else {
                    console.log("No non-zero values found in first 10x10 elements");
                }
            }
        }
    }

    // Initialize when document loads
    document.addEventListener('DOMContentLoaded', function() {
        // Create unique tooltip for timeline
        timelineTooltip = d3.select("body").append("div")
            .attr("class", "timeline-tooltip")
            .style("opacity", 0);

        // Initialize the connections modal
        timelineConnectionsModal = new bootstrap.Modal(document.getElementById('timelineConnectionsModal'));
        
        // Toggle button for shared authors
        document.getElementById('timeline-toggle-shared-authors').addEventListener('change', function() {
            timelineShowSharedAuthors = this.checked;
            timelineUpdateConnections();
        });
        
        // Radio buttons for citation mode
        document.getElementById('timeline-mode-both').addEventListener('change', function() {
            if (this.checked) {
                timelineCitationMode = "both";
                timelineUpdateConnections();
            }
        });
        
        document.getElementById('timeline-mode-cites').addEventListener('change', function() {
            if (this.checked) {
                timelineCitationMode = "cites";
                timelineUpdateConnections();
            }
        });
        
        document.getElementById('timeline-mode-cited-by').addEventListener('change', function() {
            if (this.checked) {
                timelineCitationMode = "cited-by";
                timelineUpdateConnections();
            }
        });

        // Add this after the other citation mode radio button event listeners
        document.getElementById('timeline-mode-none').addEventListener('change', function() {
            if (this.checked) {
                timelineCitationMode = "none";
                timelineUpdateConnections();
            }
        });
        
        // Add color category dropdown handler
        document.getElementById('timelineColorCategory').addEventListener('change', function() {
            updateTimelineNodeColors();
        });

        // Add this helper function at the top level of your IIFE
        function throttled(delay, fn) {
            let lastCall = 0;
            return function(...args) {
                const now = Date.now();
                if (now - lastCall < delay) {
                    return;
                }
                lastCall = now;
                return fn(...args);
            }
        }

        // Then modify the initialization section in document.addEventListener('DOMContentLoaded', ...)
        // Add throttling to the timelineInitialize call:
        const throttledInitialize = throttled(200, timelineInitialize);
        
        document.querySelectorAll('.navbar-item').forEach(navItem => {
            navItem.addEventListener('click', function() {
                if (this.getAttribute('data-section') === 'timeView') {
                    // Use setTimeout to ensure the DOM is fully ready
                    setTimeout(() => {
                        throttledInitialize();
                        populateTimelineColorCategoryDropdown(); // Populate dropdown when timeline is shown
                    }, 300);
                }
            });
        });

        // Also throttle the window resize handler
        window.addEventListener('resize', timelineDebounce(function() {
            const container = document.getElementById('timeline-graph-container');
            if (container && container.offsetParent !== null) {
                throttledInitialize();
            }
        }, 250));
        
        // Immediately try to initialize if timeline is the starting view
        setTimeout(function() {
            const timelineView = document.getElementById('timeView');
            if (timelineView && timelineView.style.display !== 'none') {
                timelineInitialize();
            }
        }, 500);
    });

    function collectVisibleRowData() {
        const filteredData = [];
        $('tbody tr:visible').each(function() {
            const rowData = {};
            $(this).find('td').each(function(index) {
                const colName = $('table thead th').eq(index).data('col');
                if (colName) {
                    rowData[colName] = $(this).text().trim();
                }
            });
            filteredData.push(rowData);
        });
        return filteredData;
    }
    
    // Debounce function to limit frequent updates
    function timelineDebounce(func, wait) {
        let timeout;
        return function() {
            const context = this;
            const args = arguments;
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(context, args), wait);
        };
    }
    
    // Process data for timeline visualization - fixed for ID type issues
    function timelineProcessData() {
        try {
            // Get data from the template
            const rawData = {{ data | tojson }};
            const citationRawMatrix = {{ citation_matrix | default('[]') | tojson }};
            const coauthorRawMatrix = {{ coauthor_matrix | default('[]') | tojson }};
            
            if (!rawData || rawData.length === 0) {
                console.error("No study data available for timeline");
                return false;
            }
            
            // Process study data
            timelineStudyData = [];
            
            // Extract studies with valid years
            for (let i = 0; i < rawData.length; i++) {
                const study = rawData[i];
                
                // Skip studies without a valid year
                if (!study.Year || study.Year === 'N/A' || isNaN(parseInt(study.Year))) {
                    continue;
                }
                
                const processedStudy = {
                    id: String(study.ID),
                    numericId: parseInt(study.ID),  // Store numeric ID for matrix lookups
                    title: study.Title || `Study ${study.ID}`,
                    authors: study['First Author'] || 'Unknown',
                    year: parseInt(study.Year),
                    bodyPart: study['Input Body Part'] || 'N/A',
                    location: study.Location || 'N/A',
                    details: study
                };
                
                timelineStudyData.push(processedStudy);
            }
            
            // Sort studies by year
            timelineStudyData.sort((a, b) => a.year - b.year);
            
            // Group studies by year
            timelineYearGroups = {};
            for (const study of timelineStudyData) {
                if (!timelineYearGroups[study.year]) {
                    timelineYearGroups[study.year] = [];
                }
                timelineYearGroups[study.year].push(study);
            }
            
            // Create mappings for both string and numeric IDs
            timelineStudyIdToIndex = {};
            timelineIdMapping = {}; // Map numeric IDs to study objects
            
            for (let i = 0; i < timelineStudyData.length; i++) {
                const study = timelineStudyData[i];
                timelineStudyIdToIndex[study.id] = i;
                timelineIdMapping[study.numericId] = study;
            }
            
            console.log("Available study IDs:", Object.keys(timelineIdMapping).join(", "));
            
            // Check if we need to process citation matrix directly
            if (citationRawMatrix && citationRawMatrix.length > 0) {
                timelineRawCitationMatrix = citationRawMatrix;
                console.log("Raw citation matrix stored for direct processing");
            }
            
            // Check if we need to process coauthor matrix directly
            if (coauthorRawMatrix && coauthorRawMatrix.length > 0) {
                timelineRawCoauthorMatrix = coauthorRawMatrix;
                console.log("Raw coauthor matrix stored for direct processing");
            }
            
            return timelineStudyData.length > 0;
        } catch (error) {
            console.error("Error processing timeline data:", error);
            return false;
        }
    }
    
    // Helper function to process matrices into a unified format
    function processTimelineMatrix(rawMatrix, allStudyIds, studyIdMapping) {
        // Create an empty matrix filled with zeros
        const studyCount = Object.keys(studyIdMapping).length;
        const processedMatrix = Array(studyCount).fill().map(() => Array(studyCount).fill(0));
        
        // If no matrix data, return the empty matrix
        if (!rawMatrix || !rawMatrix.length) {
            console.log("No matrix data provided");
            return processedMatrix;
        }
        
        try {
            console.log("Raw matrix structure:", {
                rowCount: rawMatrix.length,
                firstRowLength: rawMatrix[0] ? rawMatrix[0].length : 0,
                sampleFirstRow: rawMatrix[0] ? rawMatrix[0].slice(0, 5) : []
            });
            
            // Extract column IDs from the first row if available
            const colIds = rawMatrix[0] ? rawMatrix[0].slice(1).map(id => String(id)) : [];
            console.log("Column IDs extracted:", colIds.length, "first few:", colIds.slice(0, 5));
            
            // Process each row starting from index 1 (skipping header)
            let connectionCount = 0;
            for (let i = 1; i < rawMatrix.length; i++) {
                const row = rawMatrix[i];
                if (!row || row.length <= 1) continue;
                
                // Get source ID from the first column
                const sourceId = String(row[0]);
                if (!studyIdMapping.hasOwnProperty(sourceId)) {
                    console.log(`Source ID ${sourceId} not found in mapping, skipping row`);
                    continue;
                }
                
                const sourceIndex = studyIdMapping[sourceId];
                
                // Process each cell in this row
                for (let j = 1; j < row.length; j++) {
                    if (j-1 >= colIds.length) continue;
                    
                    const targetId = String(colIds[j-1]);
                    if (!studyIdMapping.hasOwnProperty(targetId)) {
                        // Skip silently
                        continue;
                    }
                    
                    const targetIndex = studyIdMapping[targetId];
                    const value = row[j];
                    
                    // Set connection if value is truthy (1, "1", true)
                    if (value === 1 || value === true || value === "1") {
                        processedMatrix[sourceIndex][targetIndex] = 1;
                        connectionCount++;
                    }
                }
            }
            
            console.log(`Matrix processing complete: ${connectionCount} connections found`);
            
            // Additional debug: Check if the matrix has any connections
            let matrixHasConnections = false;
            for (let i = 0; i < processedMatrix.length; i++) {
                for (let j = 0; j < processedMatrix[i].length; j++) {
                    if (processedMatrix[i][j] === 1) {
                        matrixHasConnections = true;
                        console.log(`Connection found in matrix: [${i}][${j}]`);
                        break;
                    }
                }
                if (matrixHasConnections) break;
            }
            
            if (!matrixHasConnections) {
                console.log("Warning: No connections found in the processed matrix");
            }
        } catch (error) {
            console.error("Error processing matrix data:", error);
        }
        
        return processedMatrix;
    }

        // Function to populate the color category dropdown for timeline
    function populateTimelineColorCategoryDropdown() {
        try {
            const dropdown = document.getElementById('timelineColorCategory');
            
            // Clear existing options, keeping only the default
            while (dropdown.options.length > 1) {
                dropdown.remove(1);
            }
            
            // Check if we have study details data
            if (timelineStudyData.length === 0) {
                console.log("No timeline study data available for categories");
                return;
            }
            
            // Define the column order based on the same order in similarity view
            const columnOrder = [
                "Location",
                "Input Body Part",
                "Sensing_PANEL_Sensors",
                "Sensing_PANEL_No Additional Sensing",
                "Interaction_PANEL_Number of Selected Gestures",
                "Interaction_PANEL_Resolution",
                "Interaction_PANEL_Hands-Free",
                "Interaction_PANEL_Eyes-Free",
                "Interaction_PANEL_Possible on One Ear",
                "Interaction_PANEL_Adaptation of the Interaction Detection Algorithm to the Individual User",
                "Interaction_PANEL_Discreetness of Interaction Techniques",
                "Interaction_PANEL_Social Acceptability of Interaction Techniques",
                "Interaction_PANEL_Accuracy of Interaction Recognition",
                "Interaction_PANEL_Robustness of Interaction Detection",
                "Study_PANEL_Elicitation Study",
                "Study_PANEL_Usability Evaluations",
                "Study_PANEL_Cognitive Ease Evaluations",
                "Study_PANEL_Discreetness of Interactions Evaluations",
                "Study_PANEL_Social Acceptability of Interactions Evaluations",
                "Study_PANEL_Accuracy of Interactions Evaluations",
                "Study_PANEL_Alternative Interaction Validity Evaluations",
                "Study_PANEL_Evaluation of Different Conditions",
                "Study_PANEL_Evaluation of Different Settings",
                "Device_PANEL_Earphone Type",
                "Device_PANEL_Development Stage",
                "Device_PANEL_Real-Time Processing",
                "Device_PANEL_On-Device Processing",
                "Applications_PANEL_Intended Applications"
            ];
            
            // Filter the columns to only include those available in the data
            const availableColumns = [];
            
            // Go through the ordered columns and check if they exist in the data
            for (const column of columnOrder) {
                // Check if this column exists in at least one study
                let columnExists = false;
                for (const study of timelineStudyData) {
                    if (study && study.details && 
                        study.details[column] !== undefined) {
                        columnExists = true;
                        break;
                    }
                }
                
                if (columnExists) {
                    availableColumns.push(column);
                }
            }
            
            // Add options to dropdown in the specified order
            availableColumns.forEach(category => {
                const option = document.createElement('option');
                option.value = category;  // Keep the full value for internal use
                
                // Display only the part after the last underscore
                const displayName = category.includes('_') ? 
                    category.split('_').pop() : category;
                
                option.textContent = displayName;
                dropdown.appendChild(option);
            });
            
            console.log("Timeline color category dropdown populated with options");
            
        } catch (error) {
            console.error("Error populating timeline color category dropdown:", error);
        }
    }

    // And replace the generateTimelineColorScale function with:
    function generateTimelineColorScale(category) {
        try {
            // Check cache first
            if (timelineColorScaleCache[category]) {
                return timelineColorScaleCache[category];
            }
            
            // Fields that should have parentheticals removed (from app.py)
            const parentheticalRemovalFields = [
                'Interaction_PANEL_Accuracy of Interaction Recognition',
                'Interaction_PANEL_Robustness of Interaction Detection',
                'Study_PANEL_Elicitation Study',
                'Study_PANEL_Usability Evaluations',
                'Study_PANEL_Cognitive Ease Evaluations',
                'Study_PANEL_Discreetness of Interactions Evaluations',
                'Study_PANEL_Social Acceptability of Interactions Evaluations',
                'Study_PANEL_Accuracy of Interactions Evaluations',
                'Study_PANEL_Alternative Interaction Validity Evaluations'
            ];
            
            // Should we remove parentheticals for this category?
            const shouldRemoveParenthetical = parentheticalRemovalFields.includes(category);
            
            // Collect unique values for the selected category
            const uniqueValues = new Set();
            
            // Go through all studies to collect unique values for this category
            for (const study of timelineStudyData) {
                if (!study || !study.details) continue;
                
                // Get the value for this category
                let value = study.details[category];
                
                // Skip if value is undefined or null
                if (value === undefined || value === null) continue;
                
                // Convert to string and trim
                value = String(value).trim();
                
                // Add non-empty values to the map
                if (value) {
                    // Handle comma-separated values
                    if (value.includes(',')) {
                        value.split(',').forEach(v => {
                            const trimmed = v.trim();
                            if (trimmed) {
                                if (shouldRemoveParenthetical && trimmed.includes('(')) {
                                    const baseValue = trimmed.split('(')[0].trim();
                                    uniqueValues.add(baseValue);
                                } else {
                                    uniqueValues.add(trimmed);
                                }
                            }
                        });
                    } else {
                        if (shouldRemoveParenthetical && value.includes('(')) {
                            const baseValue = value.split('(')[0].trim();
                            uniqueValues.add(baseValue);
                        } else {
                            uniqueValues.add(value);
                        }
                    }
                }
            }
            
            // Convert set to array
            const cleanedValues = Array.from(uniqueValues);
            
            // Apply custom sort logic to clean values
            const specialOrders = {
                'Yes': 1, 'Partly': 2, 'No': 3, 
                'Low': 1, 'Medium': 2, 'High': 3, 
                'Semantic': 1, 'Coarse': 2, 'Fine': 3, 'N/A': 4, 
                'Yes (Performance Loss)': 2, 'Visual Attention': 2
            };
            
            cleanedValues.sort((a, b) => {
                // Check if this is the Number of Selected Gestures field
                if (category === "Interaction_PANEL_Number of Selected Gestures") {
                    // Parse as numbers for numeric comparison
                    return parseFloat(a) - parseFloat(b);
                }
                
                const orderA = specialOrders[a] || 0;
                const orderB = specialOrders[b] || 0;
                
                // First sort by special order
                if (orderA !== orderB) {
                    return orderA - orderB;
                }
                
                // Then sort alphabetically
                return a.toLowerCase().localeCompare(b.toLowerCase());
            });
            
            // Define the custom color palette - define once to avoid recreating
            const chartColorPalette = ['#d1615d', '#5778a4', '#6a9f58', '#e49444', '#85b6b2', '#e7ca60', '#a87c9f', '#f1a2a9', '#967662', '#b8b0ac'];
            
            // Create an extended palette by duplicating and brightening the colors
            const extendedPalette = [...chartColorPalette];
            
            // Add brightened versions of each color
            chartColorPalette.forEach(color => {
                // Parse the hex color
                const rgb = d3.color(color);
                
                // Brighten the color by increasing lightness
                rgb.opacity = 0.9;  // Make slightly transparent
                const brighter = d3.color(rgb.brighter(0.7)); // Make brighter
                
                // Add the brightened color to our extended palette
                extendedPalette.push(brighter.toString());
            });
            
            // Add darker versions of each color (for options 21-30)
            chartColorPalette.forEach(color => {
                // Parse the hex color
                const rgb = d3.color(color);
                
                // Darken the color
                rgb.opacity = 1.0;  // Full opacity for darker colors
                const darker = d3.color(rgb.darker(0.7)); // Make darker
                
                // Add the darkened color to our extended palette
                extendedPalette.push(darker.toString());
            });
            
            // Generate a color scale based on the number of unique values
            let colorScale;
            
            if (cleanedValues.length <= 10) {
                // Use original color palette if we have 10 or fewer values
                colorScale = d3.scaleOrdinal()
                    .domain(cleanedValues)
                    .range(chartColorPalette.slice(0, cleanedValues.length));
            } else if (cleanedValues.length <= 20) {
                // If 11-20 values, use the extended palette with bright colors
                colorScale = d3.scaleOrdinal()
                    .domain(cleanedValues)
                    .range(extendedPalette.slice(0, cleanedValues.length));
            } else if (cleanedValues.length <= 30) {
                // If 21-30 values, use the extended palette with all 30 colors
                colorScale = d3.scaleOrdinal()
                    .domain(cleanedValues)
                    .range(extendedPalette.slice(0, cleanedValues.length));
            } else {
                // If more than 30 values, cycle through the palette
                colorScale = d3.scaleOrdinal()
                    .domain(cleanedValues)
                    .range(Array.from({ length: cleanedValues.length }, (_, i) => 
                        extendedPalette[i % extendedPalette.length]));
            }
            
            // Cache the result
            timelineColorScaleCache[category] = colorScale;
            
            return colorScale;
            
        } catch (error) {
            console.error("Error generating timeline color scale:", error);
            
            // Return a default color function that always returns the same color
            return () => "#B89491";
        }
    }

    let timelineNodeColorCache = new Map();

    function getTimelineNodeColor(node) {
        // If no category is selected, use default color
        if (!timelineCurrentColorScale) {
            return "#B89491";
        }
        
        const study = node.study;
        
        // If study doesn't exist or details are missing, use default color
        if (!study || !study.details) return "#B89491";
        
        const category = document.getElementById('timelineColorCategory').value;
        
        // Create a cache key that includes node ID and category
        const cacheKey = `${study.id}-${category}`;
        
        // Check if we have a cached result
        if (timelineNodeColorCache.has(cacheKey)) {
            return timelineNodeColorCache.get(cacheKey);
        }
        
        let rawValue = study.details[category];
        
        // If value is undefined, use default color
        if (rawValue === undefined || rawValue === null || rawValue === "") {
            const defaultColor = "#cccccc"; // Light gray for missing values
            timelineNodeColorCache.set(cacheKey, defaultColor);
            return defaultColor;
        }
        
        // Fields that should have parentheticals removed
        const parentheticalRemovalFields = [
            'Interaction_PANEL_Accuracy of Interaction Recognition',
            'Interaction_PANEL_Robustness of Interaction Detection',
            'Study_PANEL_Elicitation Study',
            'Study_PANEL_Usability Evaluations',
            'Study_PANEL_Cognitive Ease Evaluations',
            'Study_PANEL_Discreetness of Interactions Evaluations',
            'Study_PANEL_Social Acceptability of Interactions Evaluations',
            'Study_PANEL_Accuracy of Interactions Evaluations',
            'Study_PANEL_Alternative Interaction Validity Evaluations'
        ];
        
        // Should we remove parentheticals for this category?
        const shouldRemoveParenthetical = parentheticalRemovalFields.includes(category);
        
        // Check if the value contains multiple options (comma-separated)
        if (typeof rawValue === 'string' && rawValue.includes(',')) {
            // Split the value by commas and trim each value
            const values = rawValue.split(',').map(v => v.trim()).filter(v => v);
            
            // If we have multiple values after splitting, return an array of colors
            if (values.length > 1) {
                const colorArray = values.map(val => {
                    // Process each value to remove parentheticals if needed
                    if (shouldRemoveParenthetical && val.includes('(')) {
                        // Get the cleaned value for the color lookup
                        const baseValue = val.split('(')[0].trim();
                        return timelineCurrentColorScale(baseValue);
                    }
                    return timelineCurrentColorScale(val);
                });
                
                // Cache the result
                timelineNodeColorCache.set(cacheKey, colorArray);
                return colorArray;
            }
            
            // If only one value after splitting, use that single value
            if (values.length === 1) {
                let value = values[0];
                if (shouldRemoveParenthetical && value.includes('(')) {
                    value = value.split('(')[0].trim();
                }
                const color = timelineCurrentColorScale(value);
                timelineNodeColorCache.set(cacheKey, color);
                return color;
            }
        } else if (shouldRemoveParenthetical && typeof rawValue === 'string' && rawValue.includes('(')) {
            // Single value with parenthetical that needs removal
            const baseValue = rawValue.split('(')[0].trim();
            // Use the cleaned value for color scale lookup
            const color = timelineCurrentColorScale(baseValue);
            timelineNodeColorCache.set(cacheKey, color);
            return color;
        }
        
        // Single value - use the color scale to determine color
        const color = timelineCurrentColorScale(rawValue);
        timelineNodeColorCache.set(cacheKey, color);
        return color;
    }

    // Function to create a pattern fill for multi-value nodes in timeline
    function createTimelinePatternFill(nodeSelection, node, nodeRadius) {
        const colors = getTimelineNodeColor(node);
        
        // If not an array, this is a single-value node, just set the fill color directly
        if (!Array.isArray(colors) || colors.length === 1) {
            nodeSelection.style("fill", Array.isArray(colors) ? colors[0] : colors);
            return;
        }
        
        // Create a predictable pattern ID based on the colors array
        // Sort colors to ensure same combinations get the same pattern regardless of order
        const sortedColors = [...colors].sort();
        const colorHash = sortedColors.join('-');
        const patternId = `timeline-pattern-${colorHash}`.replace(/[^\w-]/g, '-');
        
        // Check if pattern already exists
        if (!document.getElementById(patternId)) {
            // Create a pattern definition if it doesn't exist yet
            const defs = timelineSvg.select("defs").empty() ? timelineSvg.append("defs") : timelineSvg.select("defs");
            
            // Create a pattern
            const pattern = defs.append("pattern")
                .attr("id", patternId)
                .attr("width", 1)
                .attr("height", 1)
                .attr("patternUnits", "objectBoundingBox")
                .attr("patternContentUnits", "objectBoundingBox");
            
            // Create a pie chart layout
            const pie = d3.pie()
                .value(() => 1)
                .sort(null)
                .padAngle(0.01);
                
            // Generate the pie segments data
            const pieData = pie(colors);
            
            // Create an arc generator for the segments
            const arc = d3.arc()
                .innerRadius(0)
                .outerRadius(0.5)
                .padAngle(0.01);
            
            // Add a group for the pie chart with proper centering
            const pieGroup = pattern.append("g")
                .attr("transform", "translate(0.5, 0.5)");
                
            // Add each segment to the pattern
            pieData.forEach(segment => {
                pieGroup.append("path")
                    .attr("d", arc(segment))
                    .style("fill", segment.data)
                    .style("stroke", "#fff")
                    .style("stroke-width", 0.02);
            });
        }
        
        // Apply the pattern to the node
        nodeSelection.style("fill", `url(#${patternId})`);
    }

    // Function to create a legend for timeline colors
    function createTimelineColorLegend() {
        try {
            // Remove any existing legend
            d3.select("#timelineColorLegend").remove();
            
            const category = document.getElementById('timelineColorCategory').value;
            
            // Only create legend if a category is selected
            if (!category || !timelineCurrentColorScale) {
                return;
            }
            
            // Fields that should have parentheticals removed (from app.py)
            const parentheticalRemovalFields = [
                'Interaction_PANEL_Accuracy of Interaction Recognition',
                'Interaction_PANEL_Robustness of Interaction Detection',
                'Study_PANEL_Elicitation Study',
                'Study_PANEL_Usability Evaluations',
                'Study_PANEL_Cognitive Ease Evaluations',
                'Study_PANEL_Discreetness of Interactions Evaluations',
                'Study_PANEL_Social Acceptability of Interactions Evaluations',
                'Study_PANEL_Accuracy of Interactions Evaluations',
                'Study_PANEL_Alternative Interaction Validity Evaluations'
            ];
            
            // Should we remove parentheticals for this category?
            const shouldRemoveParenthetical = parentheticalRemovalFields.includes(category);
            
            // Collect unique individual values for the selected category
            const valueSet = new Set();
            
            // Go through all studies to collect unique values for this category
            for (const study of timelineStudyData) {
                if (!study || !study.details) continue;
                
                // Get the value for this category
                let value = study.details[category];
                
                // Skip if value is undefined or null
                if (value === undefined || value === null) continue;
                
                // Convert to string and trim
                value = String(value).trim();
                
                if (!value) continue;
                
                // Handle comma-separated values - add each individual value to the set
                if (value.includes(',')) {
                    value.split(',').forEach(v => {
                        const trimmed = v.trim();
                        if (trimmed) {
                            // Remove parentheticals if required
                            if (shouldRemoveParenthetical && trimmed.includes('(')) {
                                const baseValue = trimmed.split('(')[0].trim();
                                valueSet.add(baseValue);
                            } else {
                                valueSet.add(trimmed);
                            }
                        }
                    });
                } else {
                    // Remove parentheticals if required
                    if (shouldRemoveParenthetical && value.includes('(')) {
                        const baseValue = value.split('(')[0].trim();
                        valueSet.add(baseValue);
                    } else {
                        valueSet.add(value);
                    }
                }
            }
            
            // Get all unique individual values
            let uniqueValues = Array.from(valueSet);
            
            // Apply custom sort logic
            const specialOrders = {
                'Yes': 1, 'Partly': 2, 'No': 3, 
                'Low': 1, 'Medium': 2, 'High': 3, 
                'Semantic': 1, 'Coarse': 2, 'Fine': 3, 'N/A': 4, 
                'Yes (Performance Loss)': 2, 'Visual Attention': 2
            };
            
            uniqueValues.sort((a, b) => {
                // Check if this is the Number of Selected Gestures field
                if (category === "Interaction_PANEL_Number of Selected Gestures") {
                    // Parse as numbers for numeric comparison
                    return parseFloat(a) - parseFloat(b);
                }
                
                // Use special order for specific values
                const orderA = specialOrders[a] || 0;
                const orderB = specialOrders[b] || 0;
                
                // First sort by special order
                if (orderA !== orderB) {
                    return orderA - orderB;
                }
                
                // Then sort alphabetically
                return a.toLowerCase().localeCompare(b.toLowerCase());
            });
            
            // Create legend container after the timeline-controls div
            const legend = d3.select("#timeline-container")
                .append("div")
                .attr("id", "timelineColorLegend")
                .style("display", "flex")
                .style("flex-wrap", "wrap")
                .style("justify-content", "center")
                .style("background", "rgba(255, 255, 255, 0.9)")
                .style("border", "1px solid #ddd")
                .style("border-radius", "4px")
                .style("padding", "12px")
                .style("margin-top", "15px")
                .style("margin-bottom", "15px")
                .style("font-size", "13px")
                .style("box-shadow", "0px 0px 5px rgba(0, 0, 0, 0.1)");
                    
            // Add title that spans the full width
            legend.append("div")
                .style("width", "100%")
                .style("font-weight", "bold")
                .style("margin-bottom", "10px")
                .style("text-align", "center")
                .text(`${category.includes('_') ? category.split('_').pop() : category}`);
                
            // Add note about multi-values
            legend.append("div")
                .style("width", "100%")
                .style("font-style", "italic")
                .style("margin-bottom", "10px")
                .style("text-align", "center")
                .style("font-size", "11px")
                .text("Note: Studies with multiple values are shown as pie charts");
                
            // Add legend items in a flex container
            const legendItems = legend.append("div")
                .style("display", "flex")
                .style("flex-wrap", "wrap")
                .style("justify-content", "center")
                .style("gap", "15px");
                
            // Add legend items in the sorted order
            uniqueValues.forEach(value => {
                const item = legendItems.append("div")
                    .style("display", "flex")
                    .style("align-items", "center")
                    .style("margin-bottom", "5px")
                    .style("margin-right", "5px");
                    
                // Color square
                item.append("div")
                    .style("width", "14px")
                    .style("height", "14px")
                    .style("background", timelineCurrentColorScale(value))
                    .style("border", "1px solid #ddd")
                    .style("margin-right", "5px");
                    
                // Value label
                item.append("div")
                    .text(value);
            });
                
        } catch (error) {
            console.error("Error creating timeline color legend:", error);
        }
    }

    // Function to update node colors in the timeline
    function updateTimelineNodeColors() {
        try {
            const category = document.getElementById('timelineColorCategory').value;
            
            // Clear node color cache when category changes
            timelineNodeColorCache.clear();
            
            // If no category selected, reset to default colors
            if (!category) {
                timelineCurrentColorScale = null;
                d3.selectAll(".timeline-node").style("fill", "#B89491");
                // Remove any existing legend
                d3.select("#timelineColorLegend").remove();
                return;
            }
            
            // Generate a new color scale for the selected category
            timelineCurrentColorScale = generateTimelineColorScale(category);
            
            // Clear any existing patterns before creating new ones
            if (timelineSvg) {
                timelineSvg.select("defs").html("");
            }
            
            // Re-sort nodes within each year based on the new category
            timelineRedrawWithColorSorting();
            
            // Create or update the color legend
            createTimelineColorLegend();
            
        } catch (error) {
            console.error("Error updating timeline node colors:", error);
        }
    }

    // Function to sort and redraw the timeline with color-based sorting within years
    function timelineRedrawWithColorSorting() {
        // Re-initialize the timeline visualization with sorted nodes
        timelineInitialize();
    }
    
    function timelineInitialize() {
        const container = document.getElementById('timeline-graph-container');
        if (!container) return;
        
        // Get container dimensions
        timelineWidth = container.offsetWidth;
        timelineHeight = 600;  // Fixed height or calculate based on data
        
        // Clear container
        container.innerHTML = '';
        
        // Process data if not done yet
        if (timelineStudyData.length === 0) {
            if (!timelineProcessData()) {
                container.innerHTML = '<div class="timeline-no-data-message">Could not load timeline data. Please check if studies with year information are available.</div>';
                return;
            }
        }
        
        // Create SVG
        timelineSvg = d3.select("#timeline-graph-container").append("svg")
            .attr("width", timelineWidth)
            .attr("height", timelineHeight);
        
        // Create layers for links and nodes
        const linksLayer = timelineSvg.append("g").attr("class", "timeline-links-layer");
        const nodesLayer = timelineSvg.append("g").attr("class", "timeline-nodes-layer");
        
        // Draw timeline
        timelineDrawLines(nodesLayer, linksLayer);
        
        // Update node colors if needed
        if (document.getElementById('timelineColorCategory').value) {
            // Add a short delay to ensure nodes are properly created first
            setTimeout(() => {
                updateTimelineNodeColors();
            }, 100);
        }
    }
    
    function timelineDrawLines(nodesLayer, linksLayer) {
        // Get sorted years
        const years = Object.keys(timelineYearGroups).sort((a, b) => parseInt(a) - parseInt(b));
        
        // Create scale for year positions
        const yearScale = d3.scalePoint()
            .domain(years)
            .range([TIMELINE_PADDING, timelineWidth - TIMELINE_PADDING])
            .padding(0.5);
        
        // Draw main timeline axis
        const timelineAxisY = timelineHeight * 0.7; // Position line at 70% of height
        
        timelineSvg.append("line")
            .attr("class", "timeline-axis")
            .attr("x1", TIMELINE_PADDING)
            .attr("y1", timelineAxisY)
            .attr("x2", timelineWidth - TIMELINE_PADDING)
            .attr("y2", timelineAxisY);
        
        // Draw year ticks and labels
        years.forEach(year => {
            const x = yearScale(year);
            
            // Draw tick
            timelineSvg.append("line")
                .attr("class", "timeline-tick")
                .attr("x1", x)
                .attr("y1", timelineAxisY - 10)
                .attr("x2", x)
                .attr("y2", timelineAxisY + 10);
            
            // Draw year label
            timelineSvg.append("text")
                .attr("class", "timeline-label")
                .attr("x", x)
                .attr("y", timelineAxisY + 30)
                .attr("text-anchor", "middle")
                .text(year);
        });
        
        // Position all nodes
        const nodes = [];
        
        // Check if color category is selected
        const category = document.getElementById('timelineColorCategory')?.value;
        
        // Helper function to get the proper category value for sorting
        function getCategoryValue(study, category) {
            if (!study || !study.details) return "";
            
            // Fields that should have parentheticals removed
            const parentheticalRemovalFields = [
                'Interaction_PANEL_Accuracy of Interaction Recognition',
                'Interaction_PANEL_Robustness of Interaction Detection',
                'Study_PANEL_Elicitation Study',
                'Study_PANEL_Usability Evaluations',
                'Study_PANEL_Cognitive Ease Evaluations',
                'Study_PANEL_Discreetness of Interactions Evaluations',
                'Study_PANEL_Social Acceptability of Interactions Evaluations',
                'Study_PANEL_Accuracy of Interactions Evaluations',
                'Study_PANEL_Alternative Interaction Validity Evaluations'
            ];
            
            // Should we remove parentheticals for this category?
            const shouldRemoveParenthetical = parentheticalRemovalFields.includes(category);
            
            // Get the raw value for this category
            let value = study.details[category];
            if (value === undefined || value === null || value === "") return "";
            
            // Convert to string and trim
            value = String(value).trim();
            
            // For multi-values, take the first one for sorting
            if (value.includes(',')) {
                const firstValue = value.split(',')[0].trim();
                
                // Handle parenthetical removal if needed
                if (shouldRemoveParenthetical && firstValue.includes('(')) {
                    return firstValue.split('(')[0].trim();
                }
                return firstValue;
            }
            
            // Handle parenthetical removal for single values
            if (shouldRemoveParenthetical && value.includes('(')) {
                return value.split('(')[0].trim();
            }
            
            return value;
        }
        
        // Process each year
        years.forEach(year => {
            const x = yearScale(year);
            let studies = timelineYearGroups[year];
            
            // Sort studies within this year by the selected category if applicable
            if (category && timelineCurrentColorScale) {
                // Define special ordering for certain values
                const specialOrders = {
                    'Yes': 1, 'Partly': 2, 'No': 3, 
                    'Low': 1, 'Medium': 2, 'High': 3, 
                    'Semantic': 1, 'Coarse': 2, 'Fine': 3, 'N/A': 4, 
                    'Yes (Performance Loss)': 2, 'Visual Attention': 2
                };
                
                // Helper function to get array of category values for a study
                function getStudyCategoryValues(study, category) {
                    if (!study || !study.details) return [];
                    
                    // Fields that should have parentheticals removed
                    const parentheticalRemovalFields = [
                        'Interaction_PANEL_Accuracy of Interaction Recognition',
                        'Interaction_PANEL_Robustness of Interaction Detection',
                        'Study_PANEL_Elicitation Study',
                        'Study_PANEL_Usability Evaluations',
                        'Study_PANEL_Cognitive Ease Evaluations',
                        'Study_PANEL_Discreetness of Interactions Evaluations',
                        'Study_PANEL_Social Acceptability of Interactions Evaluations',
                        'Study_PANEL_Accuracy of Interactions Evaluations',
                        'Study_PANEL_Alternative Interaction Validity Evaluations'
                    ];
                    
                    // Should we remove parentheticals for this category?
                    const shouldRemoveParenthetical = parentheticalRemovalFields.includes(category);
                    
                    // Get the raw value for this category
                    let value = study.details[category];
                    if (value === undefined || value === null || value === "") return [];
                    
                    // Convert to string and trim
                    value = String(value).trim();
                    
                    // Extract values
                    let values = [];
                    if (value.includes(',')) {
                        values = value.split(',')
                            .map(v => v.trim())
                            .filter(v => v);
                    } else {
                        values = [value];
                    }
                    
                    // Clean values if needed (remove parentheticals)
                    if (shouldRemoveParenthetical) {
                        values = values.map(v => {
                            if (v.includes('(')) {
                                return v.split('(')[0].trim();
                            }
                            return v;
                        });
                    }
                    
                    return values;
                }
                
                // Clone the array before sorting to avoid modifying the original
                studies = [...studies].sort((a, b) => {
                    // Get all values for the category (may be multiple for each study)
                    const valuesA = getStudyCategoryValues(a, category);
                    const valuesB = getStudyCategoryValues(b, category);
                    
                    // First, sort by number of different values (fewer values first)
                    if (valuesA.length !== valuesB.length) {
                        return valuesA.length - valuesB.length;
                    }
                    
                    // For the same number of values, sort by the values themselves
                    // Check if this is the Number of Selected Gestures field
                    if (category === "Interaction_PANEL_Number of Selected Gestures") {
                        // Sort numeric values
                        const numA = parseFloat(valuesA[0]);
                        const numB = parseFloat(valuesB[0]);
                        
                        if (!isNaN(numA) && !isNaN(numB)) {
                            return numA - numB;
                        }
                    }
                    
                    // For non-numeric values, use our special ordering if applicable
                    // Compare first values
                    if (valuesA.length > 0 && valuesB.length > 0) {
                        const orderA = specialOrders[valuesA[0]] || 0;
                        const orderB = specialOrders[valuesB[0]] || 0;
                        
                        if (orderA !== orderB) {
                            return orderA - orderB;
                        }
                        
                        // If special ordering doesn't distinguish, compare alphabetically
                        const compareResult = valuesA[0].localeCompare(valuesB[0]);
                        if (compareResult !== 0) {
                            return compareResult;
                        }
                        
                        // If first values are the same, compare second values if they exist
                        if (valuesA.length > 1 && valuesB.length > 1) {
                            const orderA2 = specialOrders[valuesA[1]] || 0;
                            const orderB2 = specialOrders[valuesB[1]] || 0;
                            
                            if (orderA2 !== orderB2) {
                                return orderA2 - orderB2;
                            }
                            
                            // Compare second values alphabetically
                            return valuesA[1].localeCompare(valuesB[1]);
                        }
                    }
                    
                    // Fall back to ID for stable sort
                    return a.id.localeCompare(b.id);
                });
            }
            
            // Check if we need multiple columns for this year
            const MAX_NODES_PER_COLUMN = 15;
            const useMultiColumn = studies.length > MAX_NODES_PER_COLUMN;
            const columnWidth = 20; // Width between columns in pixels
            
            // Stack nodes vertically above the line
            studies.forEach((study, i) => {
                let xPos = x;
                let rowIndex = i;
                
                // If using multiple columns
                if (useMultiColumn) {
                    // Determine which column this study belongs to
                    const columnIndex = Math.floor(i / MAX_NODES_PER_COLUMN);
                    rowIndex = i % MAX_NODES_PER_COLUMN;
                    
                    // Adjust x position based on column
                    // For odd columns, go right; for even columns, go left
                    const offset = columnIndex % 2 === 0 ? 
                        columnWidth * Math.ceil(columnIndex / 2) * -1 : 
                        columnWidth * Math.ceil(columnIndex / 2);
                    
                    xPos = x + offset;
                }
                
                // Calculate y position - start stacking ABOVE the timeline
                const y = timelineAxisY - (rowIndex + 1) * TIMELINE_NODE_SPACING;
                
                // Add node data with index for matrix lookups
                nodes.push({
                    id: study.id,
                    study: study,
                    x: xPos,
                    y: y,
                    index: timelineStudyIdToIndex[study.id]
                });
            });
        });
        
        // Draw connections between nodes
        timelineDrawConnections(linksLayer, nodes);
        
        // Draw nodes with color support
        timelineDrawNodes(nodesLayer, nodes);
    }
    
    // Fixed function to draw connections for index-based matrices
    function timelineDrawConnections(layer, nodes) {
        // Clear existing connections
        layer.selectAll("*").remove();
        
        console.log("Drawing timeline connections for", nodes.length, "nodes");
        console.log("Current citation mode:", timelineCitationMode);
        
        // Create node lookup by ID and numeric ID
        nodeById = {}; // Use the shared variable instead of declaring a new one
        const nodeByNumericId = {};
        nodes.forEach(node => {
            nodeById[node.id] = node;
            nodeByNumericId[node.study.numericId] = node;
        });
        
        // Arrays to store different types of connections
        const authorLinks = [];
        const citesLinks = [];
        const citedByLinks = [];

        // Debug available IDs
        console.log("Available node IDs:", Object.keys(nodeByNumericId).join(", "));
        
        // Process citation matrix - we still compute all citations even if only showing a subset
        if ({{ citation_matrix | default('[]') | tojson }}.length > 0) {
            
            const matrix = {{ citation_matrix | default('[]') | tojson }};
            console.log("Citation matrix size:", matrix.length, "rows");
            
            if (matrix.length > 1) {
                // Get header row (column IDs)
                const headerRow = matrix[0];
                
                // Process each row (skipping header row)
                for (let i = 1; i < matrix.length; i++) {
                    const row = matrix[i];
                    if (!row || row.length < 2) continue;
                    
                    // Get source ID from first column
                    // Try parsing as integer first, fallback to string
                    let sourceId;
                    try {
                        sourceId = parseInt(row[0]);
                        if (isNaN(sourceId)) sourceId = String(row[0]);
                    } catch (e) {
                        sourceId = String(row[0]);
                    }
                    
                    // Get source node
                    const sourceNode = nodeByNumericId[sourceId] || nodeById[String(sourceId)];
                    if (!sourceNode) {
                        console.log(`Source ID ${sourceId} not found in nodes`);
                        continue;
                    }
                    
                    // Process each cell in the row (connection value)
                    for (let j = 1; j < row.length; j++) {
                        // Skip if not a connection (value must be 1)
                        if (row[j] != 1) continue;
                        
                        // Get target ID from header
                        let targetId;
                        try {
                            targetId = parseInt(headerRow[j]);
                            if (isNaN(targetId)) targetId = String(headerRow[j]);
                        } catch (e) {
                            targetId = String(headerRow[j]);
                        }
                        
                        // Get target node
                        let targetNode = nodeByNumericId[targetId] || nodeById[String(targetId)];
                        if (!targetNode) {
                            console.log(`Target ID ${targetId} not found in nodes`);
                            continue;
                        }
                        
                        // IMPORTANT: The citation matrix represents "cites" relationships
                        // If row[i] -> column[j] = 1, it means paper i cites paper j
                        
                        // Add to appropriate list - every citation is both a "cites" and a "cited by" relationship
                        // depending on perspective
                        citesLinks.push({
                            source: sourceNode,
                            target: targetNode,
                            type: 'cites'
                        });
                        
                        citedByLinks.push({
                            source: targetNode,
                            target: sourceNode,
                            type: 'cited-by'
                        });
                    }
                }
            }
            
            console.log(`Citation connections: ${citesLinks.length} cites, ${citedByLinks.length} cited by`);
        }
        
        // Process coauthor matrix
        if (timelineShowSharedAuthors && 
            {{ coauthor_matrix | default('[]') | tojson }}.length > 0) {
            
            const matrix = {{ coauthor_matrix | default('[]') | tojson }};
            console.log("Coauthor matrix size:", matrix.length, "rows");
            
            if (matrix.length > 1) {
                // Track processed pairs to avoid duplicates
                const processedPairs = new Set();
                
                // Get header row (column IDs)
                const headerRow = matrix[0];
                
                // Process each row (skipping header row)
                for (let i = 1; i < matrix.length; i++) {
                    const row = matrix[i];
                    if (!row || row.length < 2) continue;
                    
                    // Get source ID from first column
                    let sourceId;
                    try {
                        sourceId = parseInt(row[0]);
                        if (isNaN(sourceId)) sourceId = String(row[0]);
                    } catch (e) {
                        sourceId = String(row[0]);
                    }
                    
                    // Get source node
                    let sourceNode = nodeByNumericId[sourceId];
                    if (!sourceNode) {
                        sourceNode = nodeById[String(sourceId)];
                        if (!sourceNode) {
                            console.log(`Source ID ${sourceId} not found in nodes (coauthor)`);
                            continue;
                        }
                    }
                    
                    // Process each cell in the row
                    for (let j = 1; j < row.length; j++) {
                        // Skip if not a connection
                        if (row[j] != 1) continue;
                        
                        // Get target ID from header
                        let targetId;
                        try {
                            targetId = parseInt(headerRow[j]);
                            if (isNaN(targetId)) targetId = String(headerRow[j]);
                        } catch (e) {
                            targetId = String(headerRow[j]);
                        }
                        
                        // Get target node
                        let targetNode = nodeByNumericId[targetId];
                        if (!targetNode) {
                            targetNode = nodeById[String(targetId)];
                            if (!targetNode) {
                                console.log(`Target ID ${targetId} not found in nodes (coauthor)`);
                                continue;
                            }
                        }
                        
                        // Create unique key for this pair to avoid duplicates
                        const pairKey = [sourceId, targetId].sort().join('-');
                        if (processedPairs.has(pairKey)) continue;
                        
                        processedPairs.add(pairKey);
                        
                        // Add connection
                        authorLinks.push({
                            source: sourceNode,
                            target: targetNode,
                            type: 'author'
                        });
                    }
                }
            }
            
            console.log(`Coauthor connections: ${authorLinks.length}`);
        }
        
        console.log("Final connections found:", {
            authorLinks: authorLinks.length,
            citesLinks: citesLinks.length,
            citedByLinks: citedByLinks.length
        });
        
        // Draw the connections based on current mode
        
        // Draw shared author links if enabled
        if (timelineShowSharedAuthors && authorLinks.length > 0) {
            layer.selectAll(".timeline-link-author")
                .data(authorLinks)
                .enter().append("path")
                .attr("class", "timeline-link timeline-link-author")
                .attr("d", d => timelineCreateLinkPath(d.source, d.target))
                .style("stroke", "#999") // Change to neutral gray color like in similarity.html
                .style("stroke-width", 1)
                .style("stroke-opacity", 0.6)
                .style("stroke-dasharray", "5,3"); // Dashed lines for shared authors
        }
        
        // Draw citation links based on selected mode
        if (timelineCitationMode === "both" || timelineCitationMode === "cites") {
            layer.selectAll(".timeline-link-cites")
                .data(citesLinks)
                .enter().append("path")
                .attr("class", "timeline-link timeline-link-cites")
                .attr("d", d => timelineCreateLinkPath(d.source, d.target))
                .style("stroke", "#999") // Change to neutral gray color like in similarity.html
                .style("stroke-width", 1)
                .style("stroke-opacity", 0.6);
        }

        if (timelineCitationMode === "both" || timelineCitationMode === "cited-by") {
            layer.selectAll(".timeline-link-cited-by")
                .data(citedByLinks)
                .enter().append("path")
                .attr("class", "timeline-link timeline-link-cited-by")
                .attr("d", d => timelineCreateLinkPath(d.source, d.target))
                .style("stroke", "#999") // Change to neutral gray color like in similarity.html
                .style("stroke-width", 1)
                .style("stroke-opacity", 0.6);
        }
    }
    
    // Improved function to create curved paths between nodes
    function timelineCreateLinkPath(source, target) {
        // Determine if this is a link between different years
        const isSameYear = source.study.year === target.study.year;
        
        if (isSameYear) {
            // For same year, create a simple arc to the side
            const midY = (source.y + target.y) / 2;
            const arcHeight = Math.abs(source.y - target.y) * 0.8;
            const arcDirection = (source.y < target.y) ? -1 : 1;
            
            return `M ${source.x},${source.y} 
                   Q ${source.x - arcHeight * arcDirection},${midY} 
                   ${target.x},${target.y}`;
        } else {
            // For different years, create a bezier curve
            const dx = target.x - source.x;
            const controlOffset = Math.min(Math.abs(dx) * 0.4, 100); // Limit control point offset
            
            // Calculate control points - higher curves for connections between distant years
            const controlX1 = source.x + Math.sign(dx) * controlOffset;
            const controlY1 = source.y - 40; // Curve upward
            const controlX2 = target.x - Math.sign(dx) * controlOffset;
            const controlY2 = target.y - 40; // Curve upward
            
            return `M ${source.x},${source.y} 
                   C ${controlX1},${controlY1} 
                     ${controlX2},${controlY2} 
                     ${target.x},${target.y}`;
        }
    }
    
    // Function to draw nodes with proper interaction and data attributes
    function timelineDrawNodes(layer, nodes) {
        // Create defs element for patterns if not exists
        if (timelineSvg.select("defs").empty()) {
            timelineSvg.append("defs");
        }
        
        // Draw nodes
        const nodeElements = layer.selectAll("circle")
            .data(nodes)
            .enter().append("circle")
            .attr("class", "timeline-node")
            .attr("data-id", d => d.id)  // Add data attribute for easier selection
            .attr("r", TIMELINE_NODE_RADIUS)
            .attr("cx", d => d.x)
            .attr("cy", d => d.y)
            .style("stroke", "#fff")
            .style("stroke-width", 2)
            .each(function(d) {
                // Apply either default color or pattern based on category
                if (timelineCurrentColorScale) {
                    createTimelinePatternFill(d3.select(this), d, TIMELINE_NODE_RADIUS);
                } else {
                    d3.select(this).style("fill", "#B89491");
                }
            });
        
        // Add existing node interaction handlers
        nodeElements
            .on("mouseover", function(event, d) {
                // Highlight node by increasing size but maintain color/pattern
                d3.select(this)
                    .attr("r", TIMELINE_NODE_RADIUS + 2);
                    
                // Don't change the fill color/pattern - just preserve what's already there
                // If using patterns, they'll automatically scale with the new radius
                    
                // Highlight connections
                timelineHighlightConnections(d.id);
                
                // Show tooltip
                timelineTooltip.transition()
                    .duration(200)
                    .style("opacity", 0.9);
                
                timelineTooltip.html(`
                    <strong>${d.study.title}</strong><br>
                    ${d.study.authors} (${d.study.year})<br>
                    ${d.study.bodyPart}, ${d.study.location}
                `)
                    .style("left", (event.pageX + 10) + "px")
                    .style("top", (event.pageY - 28) + "px");
            })
            .on("mouseout", function() {
                // Reset node size but keep original fill
                d3.select(this)
                    .attr("r", TIMELINE_NODE_RADIUS);
                
                // Reset connections highlight
                timelineResetHighlight();
                
                // Hide tooltip
                timelineTooltip.transition()
                    .duration(500)
                    .style("opacity", 0);
            })
            .on("click", function(event, d) {
                // Show connections in modal if shift key is not pressed (regular click)
                if (!event.shiftKey) {
                    showTimelineConnections(d);
                } else {
                    // Show study details using the existing modal (shift + click)
                    const customEvent = new CustomEvent('showStudyDetailsRequest', {
                        detail: { studyId: d.study.id }
                    });
                    document.dispatchEvent(customEvent);
                }
            });
    }
    
    // Improved highlight connections function with mode awareness
    function timelineHighlightConnections(nodeId) {
        const nodeIndex = timelineStudyIdToIndex[nodeId];
        if (nodeIndex === undefined) return;
        
        // Dim all links and nodes
        timelineSvg.selectAll(".timeline-link").style("opacity", 0.2);
        timelineSvg.selectAll(".timeline-node").style("opacity", 0.3);
        timelineSvg.selectAll(".timeline-node-label").style("opacity", 0.3);
        
        // Helper function to check if the node is part of the link, considering direction
        function isNodePartOfLink(link, id, mode) {
            try {
                if (!link || !link.source || !link.target) return false;
                
                // Special handling for author links
                if (link.type === "author") {
                    // For author links, we only care if the node is connected, not about direction
                    return (link.source.id === id || link.target.id === id) && timelineShowSharedAuthors;
                }
                
                // Normal handling for citation links
                if (mode === "both") {
                    return link.source.id === id || link.target.id === id;
                } else if (mode === "cites" && link.type === "cites") {
                    return link.source.id === id; // Node cites other papers
                } else if (mode === "cited-by" && link.type === "cited-by") {
                    return link.source.id === id; // Node is cited by other papers
                } else if (mode === "none") {
                    return false; // No citation links when mode is none
                }
                return false;
            } catch (e) {
                console.error("Error checking link:", e);
                return false;
            }
        }
        
        // Highlight links that include this node, respecting the citation mode
        timelineSvg.selectAll(".timeline-link").each(function(d) {
            if (d && isNodePartOfLink(d, nodeId, timelineCitationMode)) {
                const selection = d3.select(this);
                selection.style("opacity", 1)
                        .style("stroke", "#B89491")  // Use the highlight color from similarity.html
                        .style("stroke-width", 2);
                
                // Keep the dash style for author links when highlighting
                if (selection.classed("timeline-link-author")) {
                    selection.style("stroke-dasharray", "5,3");
                }
                    
                // Also highlight connected node
                if (d.source.id === nodeId) {
                    // Connected node is the target
                    d3.select(`.timeline-node[data-id="${d.target.id}"]`)
                        .style("opacity", 1);
                } else {
                    // Connected node is the source
                    d3.select(`.timeline-node[data-id="${d.source.id}"]`)
                        .style("opacity", 1);
                }
            }
        });
        
        // Always highlight the current node
        d3.select(`.timeline-node[data-id="${nodeId}"]`)
            .style("opacity", 1);
            
        // Find all connected nodes based on the selected mode
        const connectedNodeIds = new Set([nodeId]);
        
        // Also check direct links in the visualization
        timelineSvg.selectAll(".timeline-link").each(function(d) {
            if (!d) return;
            
            try {
                if (timelineCitationMode === "both") {
                    // Include all connected nodes
                    if (d.source.id === nodeId) {
                        connectedNodeIds.add(d.target.id);
                    } else if (d.target.id === nodeId) {
                        connectedNodeIds.add(d.source.id);
                    }
                } else if (timelineCitationMode === "cites") {
                    // Only include nodes that this node cites
                    if (d.source.id === nodeId && d.type === "cites") {
                        connectedNodeIds.add(d.target.id);
                    }
                } else if (timelineCitationMode === "cited-by") {
                    // Only include nodes that cite this node
                    if (d.source.id === nodeId && d.type === "cited-by") {
                        connectedNodeIds.add(d.target.id);
                    }
                }
            } catch (e) {
                console.error("Error checking link for connections:", e);
            }
        });
        
        // Highlight the connected nodes
        timelineSvg.selectAll(".timeline-node").each(function(d) {
            if (d && connectedNodeIds.has(d.id)) {
                d3.select(this).style("opacity", 1);
            }
        });
        
        // Update the tooltip to show different info based on mode
        let citesCount = 0, citedByCount = 0;
        
        timelineSvg.selectAll(".timeline-link").each(function(d) {
            if (!d) return;
            
            if (d.source.id === nodeId && d.type === "cites") {
                citesCount++;
            } else if (d.source.id === nodeId && d.type === "cited-by") {
                citedByCount++;
            }
        });
        
        // Update tooltip info with citation counts
        const tooltipNode = nodeById[nodeId];
        if (tooltipNode) {
            let tooltipContent = `
                <strong>${tooltipNode.study.title}</strong><br>
                ${tooltipNode.study.authors} (${tooltipNode.study.year})<br>
                ${tooltipNode.study.bodyPart}, ${tooltipNode.study.location}<br><br>
                <strong>Citations:</strong> Cites ${citesCount} papers, Cited by ${citedByCount} papers
            `;
            
            timelineTooltip.html(tooltipContent);
        }
    }
    
    // Updated function to reset highlight state
    function timelineResetHighlight() {
        // Reset all links to normal opacity
        timelineSvg.selectAll(".timeline-link")
            .style("opacity", 0.6)
            .style("stroke", "#999")  // Reset to neutral gray color
            .style("stroke-width", 1);
        
        // Ensure shared author links maintain their dashed style
        timelineSvg.selectAll(".timeline-link-author")
            .style("stroke-dasharray", "5,3");
        
        // Reset nodes and labels
        timelineSvg.selectAll(".timeline-node").style("opacity", 1);
        timelineSvg.selectAll(".timeline-node-label").style("opacity", 1);
    }
    
    // Fixed function to update connections
    function timelineUpdateConnections() {
        const nodes = [];
        
        // Collect all nodes
        timelineSvg.selectAll(".timeline-node").each(function(d) {
            if (d) nodes.push(d);
        });
        
        // Redraw connections with current settings
        timelineDrawConnections(timelineSvg.select(".timeline-links-layer"), nodes);
    }
    
    // Updated filter function to include numeric IDs
    function filterTimelineVisualization(filteredData) {
        try {
            // First, check if we have empty or no filtered data
            if (!filteredData || filteredData.length === 0) {
                console.log("Empty or no filtered data - clearing timeline visualization");
                
                // Reset data structures
                timelineStudyData = [];
                timelineYearGroups = {};
                timelineStudyIdToIndex = {};
                timelineIdMapping = {};
                
                // Clear the container and show a message
                const container = document.getElementById('timeline-graph-container');
                if (container) {
                    container.innerHTML = '<div class="timeline-no-data-message">No studies match your current filters.</div>';
                }
                
                return;
            }
            
            // Extract IDs from filtered data
            const filteredIds = filteredData.map(row => String(row.ID));
            
            // Reset data structures
            timelineStudyData = [];
            timelineYearGroups = {};
            timelineStudyIdToIndex = {};
            timelineIdMapping = {};
            
            // Process only filtered studies directly from the filteredData
            for (let i = 0; i < filteredData.length; i++) {
                const study = filteredData[i];
                
                // Keep only studies with valid years
                if (study.Year && 
                    study.Year !== 'N/A' && 
                    !isNaN(parseInt(study.Year))) {
                    
                    // Use the filtered data directly
                    const processedStudy = {
                        id: String(study.ID),
                        numericId: parseInt(study.ID),
                        title: study.Title || `Study ${study.ID}`,
                        authors: study['First Author'] || 'Unknown',
                        year: parseInt(study.Year),
                        bodyPart: study['Input Body Part'] || 'N/A',
                        location: study.Location || study[' Location'] || 'N/A',
                        gesture: study.Gesture || study['Gesture Type'] || study.Gestures || 'N/A',
                        details: study  // Store the entire study object
                    };
                    
                    timelineStudyData.push(processedStudy);
                }
            }
            
            // Re-sort and group studies
            timelineStudyData.sort((a, b) => a.year - b.year);
            
            for (const study of timelineStudyData) {
                if (!timelineYearGroups[study.year]) {
                    timelineYearGroups[study.year] = [];
                }
                timelineYearGroups[study.year].push(study);
            }
            
            // Rebuild ID mappings
            for (let i = 0; i < timelineStudyData.length; i++) {
                const study = timelineStudyData[i];
                timelineStudyIdToIndex[study.id] = i;
                timelineIdMapping[study.numericId] = study;
            }
            
            console.log(`Timeline filtered: ${timelineStudyData.length} studies remaining`);
            
            // Handle case where we have filtered data but none with valid years
            if (timelineStudyData.length === 0) {
                const container = document.getElementById('timeline-graph-container');
                if (container) {
                    container.innerHTML = '<div class="timeline-no-data-message">No studies with valid years match your current filters.</div>';
                }
                return;
            }
            
            // Reinitialize visualization
            timelineInitialize();
            
        } catch (error) {
            console.error("Error filtering timeline visualization:", error);
            
            // In case of error, display error message
            const container = document.getElementById('timeline-graph-container');
            if (container) {
                container.innerHTML = '<div class="timeline-no-data-message">Error filtering timeline data.</div>';
            }
        }
    }

    function showTimelineConnections(node) {
    // Find all connections for this node
    const connectionsByStudyId = new Map(); // Use a Map to track unique studies by ID
    const nodeId = node.id;
    
    // Collect all connections based on the current mode
    timelineSvg.selectAll(".timeline-link").each(function(d) {
        if (!d) return;
        
        let connectionType = '';
        let connectedNode = null;
        
        if (d.source.id === nodeId) {
            // This node is the source
            connectionType = d.type;
            connectedNode = d.target;
        } else if (d.target.id === nodeId) {
            // This node is the target
            connectionType = d.type === 'cites' ? 'cited-by' : 
                            (d.type === 'cited-by' ? 'cites' : 'author');
            connectedNode = d.source;
        } else {
            // Not connected to this node
            return;
        }
        
        // Skip connection if it doesn't match the current citation mode filter
        if (timelineCitationMode !== "both" && 
            timelineCitationMode !== "none" && 
            d.type !== timelineCitationMode && 
            d.type !== "author") {
            return;
        }
        
        if (timelineCitationMode === "none" && d.type !== "author") {
            return;
        }
        
        // Get connected node details
        const study = connectedNode.study;
        
        // If we already have this study ID, let's update its connection types
        if (connectionsByStudyId.has(study.id)) {
            const existingConnection = connectionsByStudyId.get(study.id);
            
            // Check if this connection type is already recorded
            if (!existingConnection.connectionTypes.includes(connectionType)) {
                // Add the new connection type
                existingConnection.connectionTypes.push(connectionType);
                
                // Special handling for citation connections
                // Only run this check when we add a new connection type
                if (existingConnection.connectionTypes.includes('cites') && 
                    existingConnection.connectionTypes.includes('cited-by')) {
                    // Replace individual citation types with 'both'
                    existingConnection.connectionTypes = existingConnection.connectionTypes
                        .filter(type => type !== 'cites' && type !== 'cited-by');
                    // Only add 'both' if it's not already there
                    if (!existingConnection.connectionTypes.includes('both')) {
                        existingConnection.connectionTypes.push('both');
                    }
                }
            } else if (connectionType === 'both') {
                // If we're adding 'both' directly, make sure we remove individual citation types
                existingConnection.connectionTypes = existingConnection.connectionTypes
                    .filter(type => type !== 'cites' && type !== 'cited-by');
                // Ensure 'both' is only present once
                if (!existingConnection.connectionTypes.includes('both')) {
                    existingConnection.connectionTypes.push('both');
                }
            }
        } else {
            // New study ID - add to our map
            connectionsByStudyId.set(study.id, {
                id: study.id,
                authors: study.authors,
                year: study.year,
                bodyPart: study.bodyPart,
                location: study.details && (study.details['Location'] || study.details[' Location']) || 'N/A',
                gesture: study.details && (study.details['Gesture'] || study.details['Gestures'] || study.details['Gesture Type']) || 'N/A',
                connectionTypes: [connectionType]  // Array instead of single value
            });
        }
    });
    
    // Convert the Map values to an array
    const connections = Array.from(connectionsByStudyId.values());
    
    // Sort connections
    connections.sort((a, b) => {
        // First prioritize multiple connection types
        if (a.connectionTypes.length > b.connectionTypes.length) return -1;
        if (b.connectionTypes.length > a.connectionTypes.length) return 1;
        
        // Then prioritize "both" connections
        const aHasBoth = a.connectionTypes.includes('both');
        const bHasBoth = b.connectionTypes.includes('both');
        if (aHasBoth && !bHasBoth) return -1;
        if (bHasBoth && !aHasBoth) return 1;
        
        // Then prioritize citation connections
        const aHasCitation = a.connectionTypes.includes('cites') || 
                            a.connectionTypes.includes('cited-by') || 
                            a.connectionTypes.includes('both');
        const bHasCitation = b.connectionTypes.includes('cites') || 
                            b.connectionTypes.includes('cited-by') || 
                            b.connectionTypes.includes('both');
        
        if (aHasCitation && !bHasCitation) return -1;
        if (bHasCitation && !aHasCitation) return 1;
        
        // Then sort by year
        return b.year - a.year;
    });
    
    // Get gesture type for the selected node
    const nodeGesture = node.study.details ? (node.study.details['Gesture Type'] || node.study.details['Gesture'] || node.study.details['Gestures'] || 'N/A') : 'N/A';
    
    // Build HTML for the modal
    let html = `
    <div class="connections-container">
        <h5 class="mb-3">Selected Study</h5>
        <div class="table-responsive mb-4">
            <table class="table table-striped">
                <colgroup>
                    <col style="width: 3%;">  <!-- Info icon column -->
                    <col style="width: 5%;"> <!-- ID column -->
                    <col style="width: 17%;"> <!-- Authors column -->
                    <col style="width: 8%;">  <!-- Year column -->
                    <col style="width: 15%;"> <!-- Location column -->
                    <col style="width: 12%;"> <!-- Body Part column -->
                    <col style="width: 18%;"> <!-- Gesture column -->
                    <col style="width: 10%;"> <!-- Empty column for alignment -->
                </colgroup>
                <thead>
                    <tr>
                        <th></th>
                        <th>ID</th>
                        <th>Authors</th>
                        <th>Year</th>
                        <th>Location</th>
                        <th>Body Part</th>
                        <th>Gesture</th>
                        <th></th> <!-- Empty header for alignment -->
                    </tr>
                </thead>
                <tbody>
                    <tr class="selected-study-row">
                        <td><i class="bi bi-info-circle view-study-details" title="View details" data-id="${node.study.id}"></i></td>
                        <td>${node.study.id}</td>
                        <td>${node.study.authors}</td>
                        <td>${node.study.year}</td>
                        <td>${node.study.location || 'N/A'}</td>
                        <td>${node.study.bodyPart || 'N/A'}</td>
                        <td>${nodeGesture}</td>
                        <td></td> <!-- Empty cell for alignment -->
                    </tr>
                </tbody>
            </table>
        </div>

        <h5 class="mb-3">Study Network</h5>
        `;

    // Now create the connections table
    html += `
        <div class="table-responsive">
            <table class="table table-striped">
                <colgroup>
                    <col style="width: 3%;">  <!-- Info icon column -->
                    <col style="width: 5%;"> <!-- ID column -->
                    <col style="width: 17%;"> <!-- Authors column -->
                    <col style="width: 8%;">  <!-- Year column -->
                    <col style="width: 15%;"> <!-- Location column -->
                    <col style="width: 12%;"> <!-- Body Part column -->
                    <col style="width: 18%;"> <!-- Gesture column -->
                    <col style="width: 10%;"> <!-- Connection Type column -->
                </colgroup>
                <thead>
                    <tr>
                        <th></th>
                        <th>ID</th>
                        <th>Authors</th>
                        <th>Year</th>
                        <th>Location</th>
                        <th>Body Part</th>
                        <th>Gesture</th>
                        <th>Connection Type</th>
                    </tr>
                </thead>
                <tbody>
                    `;

                    if (connections.length === 0) {
                        html += `
                                <tr>
                                    <td colspan="8" class="text-center">No connections found with current filter settings.</td>
                                </tr>
                            </tbody>
                        </table>
                        </div>`;
                    } else {
                        connections.forEach(connection => {
                            // Create an array to hold all connection displays
                            const connectionDisplays = [];
                            
                            // First deduplicate the connection types array to prevent duplicates
                            connection.connectionTypes = [...new Set(connection.connectionTypes)];
                            
                            // Process each connection type
                            connection.connectionTypes.forEach(type => {
                                let display, cls, icon;
                                
                                if (type === 'cites') {
                                    display = 'Cites';
                                    cls = 'text-primary';
                                    icon = '<i class="bi bi-arrow-right"></i>';
                                } else if (type === 'cited-by') {
                                    display = 'Cited by';
                                    cls = 'text-success';
                                    icon = '<i class="bi bi-arrow-left"></i>';
                                } else if (type === 'both') {
                                    display = 'Bidirectional Citation';
                                    cls = 'text-info';
                                    icon = '<i class="bi bi-arrow-left-right"></i>';
                                } else if (type === 'author') {
                                    display = 'Shared Author';
                                    cls = 'text-secondary';
                                    icon = '<i class="bi bi-person"></i>';
                                }
                                
                                connectionDisplays.push(`<span class="${cls}">${icon} ${display}</span>`);
                            });
                            
                            // Join the displays with a line break
                            const connectionDisplay = connectionDisplays.join('<br>');
                            
                            html += `
                                <tr>
                                    <td><i class="bi bi-info-circle view-study-details" title="View details" data-id="${connection.id}"></i></td>
                                    <td>${connection.id}</td>
                                    <td>${connection.authors || 'N/A'}</td>
                                    <td>${connection.year || 'N/A'}</td>
                                    <td>${connection.location}</td>
                                    <td>${connection.bodyPart || 'N/A'}</td>
                                    <td>${connection.gesture}</td>
                                    <td>${connectionDisplay}</td>
                                </tr>
                            `;
                        });
                        
                        html += `
                            </tbody>
                        </table>
                        </div>
                        <p class="text-muted mt-2">Total connections: ${connections.length}</p>
                    </div>`;
                    }
            
            // Set the modal content
            document.getElementById('timelineConnectionsContainer').innerHTML = html;
            
            // Add click handlers to the info icons
            setTimeout(() => {
                document.querySelectorAll('.view-study-details').forEach(icon => {
                    icon.addEventListener('click', function() {
                        const studyId = this.getAttribute('data-id');
                        // Close the modal before showing study details
                        timelineConnectionsModal.hide();
                        
                        // Dispatch event to show study details
                        const event = new CustomEvent('showStudyDetailsRequest', {
                            detail: { studyId: studyId }
                        });
                        document.dispatchEvent(event);
                    });
                });
            }, 100);
            
            // Show the modal
            timelineConnectionsModal.show();
        }
    
    // Export filter function to parent
    window.filterTimelineVisualization = filterTimelineVisualization;
})(); // End of IIFE
</script>

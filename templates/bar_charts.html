<!-- Include Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<style>
    /* Grid layout for charts */
    #chartsContainer {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); /* More responsive grid */
        gap: 20px;
        padding: 20px;
    }

    /* Add these media queries for better control on smaller screens */
    @media (max-width: 768px) {
        #chartsContainer {
            grid-template-columns: 1fr; /* Single column on small screens */
        }
        
        .chart-wrapper {
            min-height: 250px; /* Slightly smaller height */
        }
    }

    @media (min-width: 769px) and (max-width: 1200px) {
        #chartsContainer {
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr)); /* Two columns on medium screens */
        }
    }

    .chart-wrapper {
        background: #f8f9fa;
        border-radius: 8px;
        padding: 10px;
        box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1);
        min-height: 300px;
        display: flex;
        flex-direction: column;
        align-items: center;
    }

    .chart-title {
        font-size: 16px;
        text-align: center;
        margin-bottom: 10px;
        display: flex;
        align-items: center;
        gap: 5px;
    }

    .chart-title i {
        font-size: 14px;
        color: #6c757d;
        cursor: pointer;
    }

    .chart-wrapper canvas {
        width: 100% !important;
        height: 250px !important;
    }

    /* Style for transparent modal when another modal is on top */
    .transparent-background-modal {
        opacity: 0 !important;
        pointer-events: none !important;
    }
    
    .transparent-background-modal .modal-backdrop {
        opacity: 0 !important;
    }
</style>

<div class="d-flex justify-content-end mb-3 align-items-center">
    <label for="maxBarsDropdown" class="form-label me-2 mb-0">Maximum bars per chart:</label>
    <select id="maxBarsDropdown" class="form-select form-select-sm" style="width: auto;">
        <option value="10">10</option>
        <option value="20">20</option>
        <option value="30">30</option>
        <option value="40">40</option>
        <option value="50" selected>50</option>
        <option value="70">70</option>
        <option value="100">100</option>
        <option value="999">Unlimited</option>
    </select>
</div>
<div id="chartsContainer"></div>
<div id="hiddenChartsMessage" class="mt-3" style="display: none; padding: 15px;">
    <h6>Some charts exceed the maximum bar threshold and are not displayed:</h6>
    <ul id="hiddenChartsList"></ul>
</div>

<!-- Modal Structure -->
<div class="modal fade" id="infoModalBarCharts" tabindex="-1" aria-labelledby="infoModalLabelBarCharts" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-body">
                <div id="rowDetailsContainerBarCharts">
                    <!-- Row details will be populated here -->
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>

<script>

    // Store the maximum bars threshold
    let maxBarsThreshold = 50; // Default value

    // Set up event listener for the dropdown
    document.addEventListener('DOMContentLoaded', function() {
        const maxBarsDropdown = document.getElementById('maxBarsDropdown');
        
        if (maxBarsDropdown) {
            maxBarsDropdown.addEventListener('change', function() {
                // Update the threshold
                maxBarsThreshold = parseInt(this.value);
                
                // Get current filtered data from the parent window
                const filteredData = window.parent.earXploreState ? window.parent.earXploreState.filteredData : [];
                
                // Get selected columns from the parent window
                const selectedColumns = Array.from(window.parent.document.querySelectorAll('.column-toggle:checked'))
                    .map(el => el.closest('.form-check').querySelector('label').textContent);
                
                // Directly call the chart generation function with current data
                generateBarCharts(filteredData, selectedColumns);
            });
        }
        
        // Add window resize handler here
        window.addEventListener('resize', debounce(() => {
            // Only regenerate if we already have charts
            if (window.chartInstances && Object.keys(window.chartInstances).length > 0) {
                // Get current filtered data from the parent window
                const filteredData = window.parent.earXploreState ? window.parent.earXploreState.filteredData : [];
                
                // Get selected columns from the parent window
                const selectedColumns = Array.from(window.parent.document.querySelectorAll('.column-toggle:checked'))
                    .map(el => el.closest('.form-check').querySelector('label').textContent);
                
                // Call generate charts with current data (this will recalculate optimal spans)
                generateBarCharts(filteredData, selectedColumns);
            }
        }, 250));
    });

    // Cache modal instance - avoids creating a new one for each click
    document.addEventListener('DOMContentLoaded', function() {
        barChartInfoModal = new bootstrap.Modal(document.getElementById('infoModalBarCharts'));
        
        // Add event listeners for the main info modal from index.html
        const mainInfoModal = document.getElementById('infoModal');
        
        // When the main info modal opens, make the bar chart modal transparent
        mainInfoModal.addEventListener('show.bs.modal', function() {
            const barChartModalElement = document.getElementById('infoModalBarCharts');
            if (barChartModalElement && barChartModalElement.classList.contains('show')) {
                barChartModalElement.classList.add('transparent-background-modal');
            }
        });
        
        // When the main info modal closes, restore the bar chart modal
        mainInfoModal.addEventListener('hidden.bs.modal', function() {
            const barChartModalElement = document.getElementById('infoModalBarCharts');
            if (barChartModalElement) {
                barChartModalElement.classList.remove('transparent-background-modal');
            }
        });
    });

    // Shared color palette - consider moving to a separate file
    const chartColorPalette = ['#d1615d', '#5778a4', '#6a9f58', '#e49444', '#85b6b2', '#e7ca60', '#a87c9f', '#f1a2a9', '#967662', '#b8b0ac'];

    // Special order for categorical values
    const specialOrdersBarChart = {'Yes': 1, 'Partly': 2, 'No': 3, 'Low': 1, 'Medium': 2, 'High': 3, 'Semantic': 1, 'Coarse': 2, 'Fine': 3, 'Yes (Performance Loss)': 2};

    // Debounce function to limit frequent updates
    function debounce(func, wait) {
        let timeout;
        return function(...args) {
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(this, args), wait);
        };
    }

    function customSortBarChart(a, b) {
        // Special handling for N/A - always make it last
        if (a === 'N/A') return 1;  // a is N/A, move to end
        if (b === 'N/A') return -1; // b is N/A, move to end
        
        const orderA = specialOrdersBarChart[a];
        const orderB = specialOrdersBarChart[b];

        if (orderA !== undefined && orderB !== undefined) {
            return orderA - orderB; // Both are special cases, sort by their order
        } else if (orderA !== undefined) {
            return -1; // a is a special case, it comes first
        } else if (orderB !== undefined) {
            return 1; // b is a special case, it comes first
        } else {
            const numA = parseFloat(a);
            const numB = parseFloat(b);
            if (!isNaN(numA) && !isNaN(numB)) {
                return numA - numB; // Both are numbers, sort numerically
            } else {
                return a.localeCompare(b); // Default alphabetical sorting
            }
        }
    }
    
    // Create chart options centrally to avoid duplication
    function createChartOptions(col, labelCount) {
        return {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function(tooltipItem) {
                            return `${tooltipItem.raw} studies. Click for list!`;
                        }
                    }
                },
                legend: {
                    display: false
                }
            },
            scales: {
                x: {
                    stacked: false,
                    ticks: {
                        autoSkip: false,
                        callback: function(value, index, values) {
                            const label = this.getLabelForValue(value);
                            // Different truncation based on number of bars
                            let charLimit = 15; // Default
                            
                            if (labelCount === 2) {
                                charLimit = 25;
                            } else if (labelCount === 3) {
                                charLimit = 20;
                            }
                            
                            return label.length > charLimit ? label.substr(0, charLimit) + '...' : label;
                        }
                    }
                },
                y: { 
                    stacked: false, 
                    beginAtZero: true, 
                    ticks: { stepSize: 1 }
                }
            },
            onClick: (evt, activeElements) => {
                if (activeElements.length > 0) {
                    const datasetIndex = activeElements[0].index;
                    const chartInfo = window.chartInstances[col];
                    const label = chartInfo.labels[datasetIndex];
                    
                    // Create a table with the requested columns
                    const tableHTML = `
                        <h5>${col.split('_').pop()}: ${label}</h5>
                        <table class="table table-striped table-hover">
                            <thead>
                                <tr>
                                    <th></th>
                                    <th>ID</th>
                                    <th>First Author</th>
                                    <th>Year</th>
                                    <th>Location</th>
                                    <th>Input Body Part</th>
                                    <th>Gesture</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${chartInfo.uniqueGroups[label]
                                    .sort((a, b) => {
                                        // Extract numeric parts if IDs are like "P1", "P2" etc.
                                        const numA = parseInt(a["ID"].replace(/^\D+/g, ''));
                                        const numB = parseInt(b["ID"].replace(/^\D+/g, ''));
                                        
                                        // If we have valid numbers, sort numerically
                                        if (!isNaN(numA) && !isNaN(numB)) {
                                            return numA - numB;
                                        }
                                        // Fall back to string comparison
                                        return a["ID"].localeCompare(b["ID"]);
                                    })
                                    .map(row => `
                                        <tr>
                                            <td><i class="bi bi-info-circle view-details" title="View details" style="cursor: pointer;" data-id="${row["ID"]}"></i></td>
                                            <td>${row["ID"] || ''}</td>
                                            <td>${row["First Author"] || ''}</td>
                                            <td>${row["Year"] || ''}</td>
                                            <td>${row["Location"] || ''}</td>
                                            <td>${row["Input Body Part"] || ''}</td>
                                            <td>${row["Gesture"] || ''}</td>
                                        </tr>
                                    `).join('')
                                }
                            </tbody>
                        </table>
                    `;
                                        
                    document.getElementById('rowDetailsContainerBarCharts').innerHTML = tableHTML;
                    
                    // Add event listeners to the info icons in the modal
                    document.querySelectorAll('#rowDetailsContainerBarCharts .view-details').forEach(icon => {
                        icon.addEventListener('click', function() {
                            const studyId = this.getAttribute('data-id');
                            // Don't close the current modal - remove this line
                            // barChartInfoModal.hide();
                            
                            // Dispatch custom event that index.html can listen for
                            const event = new CustomEvent('showStudyDetailsRequest', {
                                detail: { studyId: studyId }
                            });
                            document.dispatchEvent(event);
                        });
                    });
                    
                    // Use cached modal instance
                    barChartInfoModal.show();
                }
            }
        };
    }

    function updateOrCreateChart(col, labels, dataValues, uniqueGroups, barThickness) {
        const explanations = {{ explanations | tojson }};
        const container = document.getElementById('chartsContainer');
        const chartId = `chart-${col.replace(/\s+/g, '-')}`;
        
        // Get the column index for ordering
        const columns = {{ data[0].keys() | list | tojson }};
        const columnIndex = columns.indexOf(col);
        
        if (window.chartInstances[col]) {
            // Update existing chart
            const chart = window.chartInstances[col].chart;
            
            // Update chart data - batch all updates before calling chart.update()
            chart.data.labels = labels;
            chart.data.datasets[0].data = dataValues;
            chart.data.datasets[0].backgroundColor = labels.map((_, index) => 
                chartColorPalette[index % chartColorPalette.length]);
            chart.data.datasets[0].barThickness = barThickness;
            
            // Store updated data for click handler
            window.chartInstances[col].labels = labels;
            window.chartInstances[col].uniqueGroups = uniqueGroups;
            
            // Update options with new label count
            chart.options = createChartOptions(col, labels.length);
            
            // Apply changes once
            chart.update();
        } else {
            // Create new chart container
            const chartContainer = document.createElement('div');
            chartContainer.id = `chart-container-${col.replace(/\s+/g, '-')}`;
            chartContainer.classList.add("chart-wrapper");
            
            // Store column index for ordering
            chartContainer.dataset.columnIndex = columnIndex;
            
            // Get explanation if available
            const explanation = explanations[col] || '';
            
            // Use document fragment for better performance
            const fragment = document.createDocumentFragment();
            
            // Create chart title
            const heading = document.createElement('h4');
            heading.className = 'chart-title';
            heading.textContent = col.split('_').pop();
            
            if (explanation) {
                const icon = document.createElement('i');
                icon.className = 'bi bi-question-circle-fill';
                icon.title = explanation;
                heading.appendChild(icon);
            }
            
            // Create canvas for chart
            const canvas = document.createElement('canvas');
            canvas.id = chartId;
            
            // Build the DOM structure
            fragment.appendChild(heading);
            fragment.appendChild(canvas);
            chartContainer.appendChild(fragment);
            
            // Insert in the correct position based on column index
            let inserted = false;
            const existingCharts = Array.from(container.children);
            
            for (let i = 0; i < existingCharts.length; i++) {
                const existingIndex = parseInt(existingCharts[i].dataset.columnIndex, 10);
                if (columnIndex < existingIndex) {
                    container.insertBefore(chartContainer, existingCharts[i]);
                    inserted = true;
                    break;
                }
            }
            
            // If not inserted (belongs at the end), append it
            if (!inserted) {
                container.appendChild(chartContainer);
            }

            // Create the chart with label count
            const chart = new Chart(document.getElementById(chartId).getContext('2d'), {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Number of Studies',
                        data: dataValues,
                        backgroundColor: labels.map((_, index) => chartColorPalette[index % chartColorPalette.length]),
                        barThickness: barThickness
                    }]
                },
                options: createChartOptions(col, labels.length)
            });
            
            // Track the chart instance
            window.chartInstances[col] = {
                chart: chart,
                labels: labels,
                uniqueGroups: uniqueGroups
            };
        }
    }

    // Add this function before the generateBarCharts function
    function calculateOptimalSpan(container, labels, totalCharts) {
        // Get container width
        const containerWidth = container.clientWidth;
        
        // Base chart size calculations
        const minChartWidth = 350; // Minimum readable chart width
        
        // Calculate how many charts fit in a row at minimum width
        const chartsPerRow = Math.max(1, Math.floor(containerWidth / minChartWidth));
        
        // Calculate spans based on label count and charts per row
        if (chartsPerRow === 1) {
            // On very small screens, everything gets full width
            return "span 1";
        } else if (chartsPerRow === 2) {
            // On medium screens, adjust based on bar count
            if (labels.length > 40) return "span 2"; // Full width
            if (labels.length > 20) return "span 1"; // Half width
            return ""; // Default (fits in standard grid)
        } else {
            // On large screens, use the existing logic
            if (labels.length <= 15) {
                return ""; // Default width 
            } else if (labels.length > 15 && labels.length <= 30) {
                return "span 2"; // Double width
            } else if (labels.length > 30 && labels.length <= 50) {
                return "span 3"; // Triple width
            } else if (labels.length > 50 && labels.length <= 75) {
                return "span 4"; // Triple width
            } else {
                return "span 5"; // Quadruple width
            }
        }
    }
        
    function generateBarCharts(filteredData, selectedColumns) {
        // Initialize chart tracking if needed
        if (!window.chartInstances) {
            window.chartInstances = {};
        }
        
        // Keep track of active columns
        const activeColumns = new Set();
        
        // Define columns that should never be displayed as charts
        const excludedChartColumns = ['ID', 'First Author', 'Abstract', 'Study Link'];
        
        // Process which columns to display
        const columnsToProcess = [];
        const columns = {{ data[0].keys() | list | tojson }};
        const tableData = filteredData || {{ data | tojson }};
        
        columns.forEach(col => {
            // Check if the column should be excluded from charts
            const colName = col.split('_').pop();
            if (col !== 'Author' && selectedColumns.includes(colName) && !excludedChartColumns.includes(colName)) {
                columnsToProcess.push(col);
                activeColumns.add(col);
            }
        });

        // Process all data once and store in a map for reuse
        const columnDataMap = {};
        
        columnsToProcess.forEach(col => {
            // Process data for this column efficiently
            const uniqueGroups = {};
            
            // List of columns with parenthetical content to clean
            const parenthetical_columns = [
                'Interaction_PANEL_Accuracy of Interaction Recognition',
                'Interaction_PANEL_Robustness of Interaction Detection',
                'Study_PANEL_Elicitation Study',
                'Study_PANEL_Usability Evaluations',
                'Study_PANEL_Cognitive Ease Evaluations',
                'Study_PANEL_Discreetness of Interactions Evaluations',
                'Study_PANEL_Social Acceptability of Interactions Evaluations',
                'Study_PANEL_Accuracy of Interactions Evaluations',
                'Study_PANEL_Alternative Interaction Validity Evaluations'
            ];
            
            // Function to extract base value (before parentheses)
            function extractBaseValue(value) {
                return value.replace(/\s*\(.*\)$/, '').trim();
            }
            
            tableData.forEach(row => {
                const cellText = row[col] || "Unknown";
                const cellValues = cellText.split(',').map(value => value.trim());
                
                cellValues.forEach(value => {
                    // Clean parenthetical content if this is one of the specified columns
                    const cleanValue = parenthetical_columns.includes(col) ? 
                        extractBaseValue(value) : value;
                    
                    if (!uniqueGroups[cleanValue]) {
                        uniqueGroups[cleanValue] = [];
                    }
                    uniqueGroups[cleanValue].push(row);
                });
            });
            
            // Prepare data for the chart
            const labels = Object.keys(uniqueGroups);
            labels.sort(customSortBarChart);
            const dataValues = labels.map(label => uniqueGroups[label].length);

            // Calculate dynamic bar thickness once
            const maxBarThickness = 30;
            const minBarThickness = 5;
            const barThickness = Math.max(minBarThickness, Math.min(maxBarThickness, 250 / labels.length));
            
            // Store processed data
            columnDataMap[col] = {
                uniqueGroups,
                labels,
                dataValues,
                barThickness
            };
        });
        
        // Replace the current chart creation/removal logic in the columnsToProcess.forEach loop
        columnsToProcess.forEach(col => {
            const { uniqueGroups, labels, dataValues, barThickness } = columnDataMap[col];
            
            // Check if this chart has too many bars (using the configurable threshold)
            if (maxBarsThreshold !== -1 && labels.length > maxBarsThreshold) {
                // If the chart already exists, remove it - too many bars to display clearly
                if (window.chartInstances[col] && window.chartInstances[col].chart) {
                    window.chartInstances[col].chart.destroy();
                    const containerId = `chart-container-${col.replace(/\s+/g, '-')}`;
                    const container = document.getElementById(containerId);
                    if (container) {
                        container.remove();
                    }
                    delete window.chartInstances[col];
                }
            } else {
                // Create or update chart
                updateOrCreateChart(col, labels, dataValues, uniqueGroups, barThickness);
                
                // Replace the progressive width scaling code in generateBarCharts function
                const containerId = `chart-container-${col.replace(/\s+/g, '-')}`;
                const container = document.getElementById(containerId);
                if (container) {
                    const chartContainer = document.getElementById('chartsContainer');
                    const span = calculateOptimalSpan(chartContainer, labels, columnsToProcess.length);
                    container.style.gridColumn = span;
                }
            }
        });
        
        // Clean up charts for columns that are no longer active
        Object.keys(window.chartInstances || {}).forEach(col => {
            if (!activeColumns.has(col)) {
                // Remove this chart and clean up
                if (window.chartInstances[col] && window.chartInstances[col].chart) {
                    window.chartInstances[col].chart.destroy();
                    const containerId = `chart-container-${col.replace(/\s+/g, '-')}`;
                    const container = document.getElementById(containerId);
                    if (container) {
                        container.remove();
                    }
                    delete window.chartInstances[col];
                }
            }
        });
        // Track charts that exceed threshold for notification
        const hiddenCharts = [];

        columnsToProcess.forEach(col => {
            const { labels } = columnDataMap[col];
            
            // If chart exceeds threshold, add to hidden charts list
            if (maxBarsThreshold !== 999 && labels.length > maxBarsThreshold) {
                hiddenCharts.push({
                    name: col.split('_').pop(),
                    count: labels.length
                });
            }
        });

        // Update the hidden charts message
        const hiddenChartsMessage = document.getElementById('hiddenChartsMessage');
        const hiddenChartsList = document.getElementById('hiddenChartsList');

        if (hiddenCharts.length > 0) {
            // Sort hidden charts by name
            hiddenCharts.sort((a, b) => a.name.localeCompare(b.name));
            
            // Create list items for each hidden chart
            hiddenChartsList.innerHTML = hiddenCharts.map(chart => 
                `<li><strong>${chart.name}</strong>: ${chart.count} bars (exceeds threshold of ${maxBarsThreshold})</li>`
            ).join('');
            
            // Show the message
            hiddenChartsMessage.style.display = 'block';
        } else {
            // Hide the message if no charts are hidden
            hiddenChartsMessage.style.display = 'none';
        }
    }
    
    // Create a debounced version that can be used where rapid updates might occur
    const debouncedGenerateBarCharts = debounce(generateBarCharts, 250);
    
    // Expose both regular and debounced versions
    window.generateBarCharts = generateBarCharts;
    window.debouncedGenerateBarCharts = debouncedGenerateBarCharts;
    
    // Add a specialized chart width manager
    (function() {
        // Create a MutationObserver to watch for chart additions
        const chartsObserver = new MutationObserver(mutations => {
            mutations.forEach(mutation => {
                // Check if charts were added
                if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
                    // Force layout recalculation after charts are rendered
                    correctChartWidths();
                }
            });
        });
        
        // Start observing the charts container
        document.addEventListener('DOMContentLoaded', () => {
            const container = document.getElementById('chartsContainer');
            chartsObserver.observe(container, { childList: true });
            
            // Initial chart creation is typically triggered from parent window
            // Add a backup timer to ensure charts are properly sized
            setTimeout(correctChartWidths, 300);
        });
        
        // Check if we're in an iframe and listen for iframe load events
        if (window !== window.parent) {
            window.addEventListener('load', () => setTimeout(correctChartWidths, 100));
        }
        
        // Define the width correction function
        function correctChartWidths() {
            // Only run if we have chart instances
            if (!window.chartInstances || Object.keys(window.chartInstances).length === 0) return;
            
            const container = document.getElementById('chartsContainer');
            
            // Process each chart
            Object.keys(window.chartInstances).forEach(col => {
                const containerId = `chart-container-${col.replace(/\s+/g, '-')}`;
                const chartContainer = document.getElementById(containerId);
                
                if (chartContainer && window.chartInstances[col]) {
                    const { labels } = window.chartInstances[col];
                    
                    // Force recalculation with container measurements
                    const span = calculateOptimalSpan(container, labels, Object.keys(window.chartInstances).length);
                    chartContainer.style.gridColumn = span;
                    
                    // Force chart redraw by resizing it
                    window.chartInstances[col].chart.resize();
                }
            });
        }
        
        // Also handle potential visibility changes (tab switching, etc)
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible') {
                setTimeout(correctChartWidths, 100);
            }
        });
        
        // Register with resize observer for more precise size monitoring
        if ('ResizeObserver' in window) {
            const resizeObserver = new ResizeObserver(debounce(() => {
                correctChartWidths();
            }, 250));
            
            document.addEventListener('DOMContentLoaded', () => {
                const container = document.getElementById('chartsContainer');
                resizeObserver.observe(container);
            });
        }
        
        // Add this to parent page communication
        window.correctChartWidths = correctChartWidths;
    })();
</script>

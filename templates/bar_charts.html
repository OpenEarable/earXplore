<!-- Include Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<style>
    /* Grid layout for charts */
    #chartsContainer {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); /* Responsive grid */
        gap: 20px;
        padding: 20px;
    }

    .chart-wrapper {
        background: #f8f9fa;
        border-radius: 8px;
        padding: 10px;
        box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1);
        min-height: 300px;
        display: flex;
        flex-direction: column;
        align-items: center;
    }

    .chart-title {
        font-size: 16px;
        text-align: center;
        margin-bottom: 10px;
        display: flex;
        align-items: center;
        gap: 5px;
    }

    .chart-title i {
        font-size: 14px;
        color: #6c757d;
        cursor: pointer;
    }

    .chart-wrapper canvas {
        width: 100% !important;
        height: 250px !important;
    }
</style>

<div id="chartsContainer"></div>

<!-- Modal Structure -->
<div class="modal fade" id="infoModalBarCharts" tabindex="-1" aria-labelledby="infoModalLabelBarCharts" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-body">
                <div id="rowDetailsContainerBarCharts">
                    <!-- Row details will be populated here -->
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>

<script>
    // Cache modal instance - avoids creating a new one for each click
    let barChartInfoModal;
    document.addEventListener('DOMContentLoaded', function() {
        barChartInfoModal = new bootstrap.Modal(document.getElementById('infoModalBarCharts'));
    });

    // Shared color palette - consider moving to a separate file
    const chartColorPalette = ['#d1615d', '#5778a4', '#6a9f58', '#e49444', '#85b6b2', '#e7ca60', '#a87c9f', '#f1a2a9', '#967662', '#b8b0ac'];

    // Special order for categorical values
    const specialOrdersBarChart = {'Yes': 1, 'Partly': 2, 'No': 3, 'Low': 1, 'Medium': 2, 'High': 3, 'Semantic': 1, 'Coarse': 2, 'Fine': 3};

    // Debounce function to limit frequent updates
    function debounce(func, wait) {
        let timeout;
        return function(...args) {
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(this, args), wait);
        };
    }

    function customSortBarChart(a, b) {
        // Special handling for N/A - always make it last
        if (a === 'N/A') return 1;  // a is N/A, move to end
        if (b === 'N/A') return -1; // b is N/A, move to end
        
        const orderA = specialOrdersBarChart[a];
        const orderB = specialOrdersBarChart[b];

        if (orderA !== undefined && orderB !== undefined) {
            return orderA - orderB; // Both are special cases, sort by their order
        } else if (orderA !== undefined) {
            return -1; // a is a special case, it comes first
        } else if (orderB !== undefined) {
            return 1; // b is a special case, it comes first
        } else {
            const numA = parseFloat(a);
            const numB = parseFloat(b);
            if (!isNaN(numA) && !isNaN(numB)) {
                return numA - numB; // Both are numbers, sort numerically
            } else {
                return a.localeCompare(b); // Default alphabetical sorting
            }
        }
    }
    
    // Create chart options centrally to avoid duplication
    function createChartOptions(col) {
        return {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function(tooltipItem) {
                            return `${tooltipItem.raw} studies. Click for list!`;
                        }
                    }
                },
                legend: {
                    display: false
                }
            },
            scales: {
                x: {
                    stacked: false,
                    ticks: {
                        autoSkip: false,
                        callback: function(value, index, values) {
                            const label = this.getLabelForValue(value);
                            return label.length > 15 ? label.substr(0, 15) + '...' : label;
                        }
                    }
                },
                y: { 
                    stacked: false, 
                    beginAtZero: true, 
                    ticks: { stepSize: 1 }
                }
            },
            onClick: (evt, activeElements) => {
                if (activeElements.length > 0) {
                    const datasetIndex = activeElements[0].index;
                    const chartInfo = window.chartInstances[col];
                    const label = chartInfo.labels[datasetIndex];
                    const studies = `<h5>${col.split('_').pop()}: ${label}</h5>` + 
                        chartInfo.uniqueGroups[label]
                        .sort((a, b) => a["Author"].localeCompare(b["Author"]))
                        .map(row => `${row["Author"]}., (${row["Year"]})`)
                        .join("<br>");
                    document.getElementById('rowDetailsContainerBarCharts').innerHTML = studies;
                    
                    // Use cached modal instance
                    barChartInfoModal.show();
                }
            }
        };
    }

    // Create or update a chart - extracted logic for better organization
    function updateOrCreateChart(col, labels, dataValues, uniqueGroups, barThickness) {
        const explanations = {{ explanations | tojson }};
        const container = document.getElementById('chartsContainer');
        const chartId = `chart-${col.replace(/\s+/g, '-')}`;
        
        if (window.chartInstances[col]) {
            // Update existing chart
            const chart = window.chartInstances[col].chart;
            
            // Update chart data - batch all updates before calling chart.update()
            chart.data.labels = labels;
            chart.data.datasets[0].data = dataValues;
            chart.data.datasets[0].backgroundColor = labels.map((_, index) => 
                chartColorPalette[index % chartColorPalette.length]);
            chart.data.datasets[0].barThickness = barThickness;
            
            // Store updated data for click handler
            window.chartInstances[col].labels = labels;
            window.chartInstances[col].uniqueGroups = uniqueGroups;
            
            // Apply changes once
            chart.update();
        } else {
            // Create new chart container
            const chartContainer = document.createElement('div');
            chartContainer.id = `chart-container-${col.replace(/\s+/g, '-')}`;
            chartContainer.classList.add("chart-wrapper");
            
            // Get explanation if available
            const explanation = explanations[col] || '';
            
            // Use document fragment for better performance
            const fragment = document.createDocumentFragment();
            
            // Create chart title
            const heading = document.createElement('h4');
            heading.className = 'chart-title';
            heading.textContent = col.split('_').pop();
            
            if (explanation) {
                const icon = document.createElement('i');
                icon.className = 'bi bi-question-circle-fill';
                icon.title = explanation;
                heading.appendChild(icon);
            }
            
            // Create canvas for chart
            const canvas = document.createElement('canvas');
            canvas.id = chartId;
            
            // Build the DOM structure with a single operation
            fragment.appendChild(heading);
            fragment.appendChild(canvas);
            chartContainer.appendChild(fragment);
            container.appendChild(chartContainer);

            // Create the chart
            const chart = new Chart(document.getElementById(chartId).getContext('2d'), {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Number of Studies',
                        data: dataValues,
                        backgroundColor: labels.map((_, index) => chartColorPalette[index % chartColorPalette.length]),
                        barThickness: barThickness
                    }]
                },
                options: createChartOptions(col)
            });
            
            // Track the chart instance
            window.chartInstances[col] = {
                chart: chart,
                labels: labels,
                uniqueGroups: uniqueGroups
            };
        }
    }
        
    function generateBarCharts(filteredData, selectedColumns) {
        // Initialize chart tracking if needed
        if (!window.chartInstances) {
            window.chartInstances = {};
        }
        
        // Keep track of active columns
        const activeColumns = new Set();
        
        // Define columns that should never be displayed as charts
        const excludedChartColumns = ['ID', 'Main Author', 'Abstract', 'Study Link'];
        
        // Process which columns to display
        const columnsToProcess = [];
        const columns = {{ data[0].keys() | list | tojson }};
        const tableData = filteredData || {{ data | tojson }};
        
        columns.forEach(col => {
            // Check if the column should be excluded from charts
            const colName = col.split('_').pop();
            if (col !== 'Author' && selectedColumns.includes(colName) && !excludedChartColumns.includes(colName)) {
                columnsToProcess.push(col);
                activeColumns.add(col);
            }
        });

        // Process all data once and store in a map for reuse
        const columnDataMap = {};
        
        columnsToProcess.forEach(col => {
            // Process data for this column efficiently
            const uniqueGroups = {};
            
            tableData.forEach(row => {
                const cellText = row[col] || "Unknown";
                const cellValues = cellText.split(',').map(value => value.trim());
                
                cellValues.forEach(value => {
                    if (!uniqueGroups[value]) {
                        uniqueGroups[value] = [];
                    }
                    uniqueGroups[value].push(row);
                });
            });
            
            // Prepare data for the chart
            const labels = Object.keys(uniqueGroups);
            labels.sort(customSortBarChart);
            const dataValues = labels.map(label => uniqueGroups[label].length);

            // Calculate dynamic bar thickness once
            const maxBarThickness = 30;
            const minBarThickness = 5;
            const barThickness = Math.max(minBarThickness, Math.min(maxBarThickness, 250 / labels.length));
            
            // Store processed data
            columnDataMap[col] = {
                uniqueGroups,
                labels,
                dataValues,
                barThickness
            };
        });
        
        // Create or update charts using the processed data
        columnsToProcess.forEach(col => {
    const { uniqueGroups, labels, dataValues, barThickness } = columnDataMap[col];
    
    // Check if this chart has too many bars (25+)
    if (labels.length > 25) {
        // If the chart already exists, remove it
        if (window.chartInstances[col] && window.chartInstances[col].chart) {
            window.chartInstances[col].chart.destroy();
            const containerId = `chart-container-${col.replace(/\s+/g, '-')}`;
            const container = document.getElementById(containerId);
            if (container) {
                container.remove();
            }
            delete window.chartInstances[col];
        }
    } else {
        // Only create/update charts with 25 or fewer bars
        updateOrCreateChart(col, labels, dataValues, uniqueGroups, barThickness);
    }
});
        
        // Clean up charts for columns that are no longer active
        Object.keys(window.chartInstances || {}).forEach(col => {
            if (!activeColumns.has(col)) {
                // Remove this chart and clean up
                if (window.chartInstances[col] && window.chartInstances[col].chart) {
                    window.chartInstances[col].chart.destroy();
                    const containerId = `chart-container-${col.replace(/\s+/g, '-')}`;
                    const container = document.getElementById(containerId);
                    if (container) {
                        container.remove();
                    }
                    delete window.chartInstances[col];
                }
            }
        });
    }
    
    // Create a debounced version that can be used where rapid updates might occur
    const debouncedGenerateBarCharts = debounce(generateBarCharts, 250);
    
    // Expose both regular and debounced versions
    window.generateBarCharts = generateBarCharts;
    window.debouncedGenerateBarCharts = debouncedGenerateBarCharts;
</script>

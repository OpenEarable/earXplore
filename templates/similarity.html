<!-- Include D3.js -->
<script src="https://d3js.org/d3.v7.min.js"></script>

<style>
    #similarityContainer {
        background: #f8f9fa;
        border-radius: 8px;
        padding: 20px;
        box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1);
        margin: 20px 0;
    }
    
    .controls {
        margin-bottom: 20px;
        display: flex;
        align-items: center;
        gap: 15px;
    }
    
    .node {
        cursor: pointer;
    }
    
    .link {
        stroke: #999;
        stroke-opacity: 0.6;
        fill: none;
    }
    
    .node-label {
        font-size: 10px;
        pointer-events: none;
    }
    
    .tooltip {
        position: absolute;
        background: white;
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 8px;
        pointer-events: none;
        box-shadow: 0px 0px 5px rgba(0, 0, 0, 0.2);
        z-index: 1000;
    }
    
    /* Match slider color with site theme */
    .noUi-connect {
        background: #B89491;
    }
    
    /* Error message style */
    .error-message {
        color: #721c24;
        background-color: #f8d7da;
        border-color: #f5c6cb;
        padding: 15px;
        border-radius: 5px;
        margin-bottom: 20px;
    }
    
    /* Loading indicator style */
    .loading-indicator {
        text-align: center;
        padding: 20px;
    }
    
    /* Important: Set minimum dimensions for the graph container */
    #graphContainer {
    width: 100%;
    border: 1px solid #ddd;
    border-radius: 5px;
    overflow: visible;
    margin-bottom: 20px; /* Add some space below the visualization */
    padding: 40px 0px 40px 0px; /* Top, Right, Bottom, Left padding */

}

    .info-icon {
        cursor: pointer;
        transition: transform 0.2s ease, fill 0.2s ease;
    }

    .info-icon:hover {
        fill: #a37c79 !important;
        transform: scale(1.2);
    }

    /* Connections modal styles */
    .connections-container h5 {
        margin-bottom: 15px;
        color: #B89491;
    }

    .connections-container .table {
        font-size: 14px;
        table-layout: fixed;
        width: 100%;
    }

    .connections-container .table th {
        background-color: #f8f9fa;
        font-size: 14px;
    }

    .connections-container .table td {
        font-size: 14px;
        vertical-align: middle;
    }

    .table-responsive {
        margin-bottom: 1.5rem;
    }


    .view-study-details:hover {
        color: #a37c79;
    }

    .selected-study-row {
        background-color: #e2f0fb !important;
    }

    /* For handling modal interactions */
    .transparent-background-modal {
        opacity: 0 !important;
        pointer-events: none !important;
    }

    /* Add these styles to your existing style section */
    .slider-container {
        padding: 0 20px; /* Adjust the padding as needed */
        margin-top: 5px; /* Add extra space underneath the slider */
        margin-bottom: 30px; /* Add extra space underneath the slider */
    }

    .slider-container .noUi-tooltip {
        bottom: -25px; /* Adjust this value as needed to move the tooltip further down */
        padding: 0px 0px; /* Adjust the padding as needed */
    }

    .noUi-tooltip {
        background: none; /* Remove background */
        border: none; /* Remove border */
        box-shadow: none; /* Remove box shadow */
        color: inherit; /* Inherit text color */
        padding: 0; /* Remove padding */
        bottom: -5px; /* Adjust this value as needed to move the tooltip further down */
    }

</style>

<div id="similarityContainer">
    <div class="controls">
        <div class="slider-container">
            <label for="thresholdSlider" style="margin-bottom: 12px; display: block;">
                <strong>Similarity Threshold (Ïƒ):</strong> <span id="thresholdValue" style="font-weight: bold; color: #B89491;">1.00</span>
                <i class="bi bi-question-circle-fill" title="This visualization shows semantic similarity between paper abstracts. Similarities were calculated using Google Gemini embeddings (gemini-embedding-exp-03-07) with cosine similarity and then z-standardized. Values above 0 indicate above-average similarity (0=mean, 1=one standard deviation above mean). Higher thresholds show only the most similar papers." style="cursor: pointer; margin-left: 5px;"></i>
            </label>           
            <div style="display: flex; align-items: center; width: 400px;">
                <span style="margin-right: 10px; font-size: inherit; color: inherit;" class="noUi-tooltip-style">-3</span>
                <div id="thresholdSlider" class="similarity-slider" style="flex: 1;"></div>
                <span style="margin-left: 10px; font-size: inherit; color: inherit;" class="noUi-tooltip-style">3</span>
            </div>
        </div>

        <!-- Add color category dropdown -->
        <div class="category-dropdown-container">
            <label for="similarityColorCategory" style="margin-bottom: 12px; display: block;">
                <strong>Color Nodes by:</strong>
            </label>
            <select id="similarityColorCategory" class="form-select" style="width: 200px;">
                <option value="">None</option>
                <!-- Category options will be populated dynamically -->
            </select>
        </div>
    </div>
    
    <div id="graphContainer"></div>

    <div class="modal fade" id="connectionsModal" tabindex="-1" aria-labelledby="connectionsModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-body">
                    <div id="connectionsContainer">
                        <!-- Connected studies will be populated here -->
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    // Initialize global variables
    let svg;
    let width, height;
    let zoom;
    let tooltip;
    let studyIds = [];
    let similarityMatrix = [];
    let originalStudyIds = []; // To store the original study IDs
    let originalSimilarityMatrix = []; // To store the original similarity matrix
    let currentColorScale = null; // To store the current color scale
    let studyDetailsCache = {}; // To store study details
    
    // Helper function for debugging
    function debug(message, obj = null) {
    }
    
    // Show status/error message
    function showStatus(message, isError = false) {
        if (isError) {
        console.error(message);
        }
    }

    // Modify the processSimilarityData function to cache the original data
    function processSimilarityData() {
        try {
            // Get the raw data from the template
            const rawData = {{ similarity_data | tojson }};
            
            debug("Raw similarity data received", rawData);
            
            if (!rawData || !rawData.abstract_study_ids || rawData.abstract_study_ids.length === 0) {
                showStatus("No similarity data available. Please check if the data file exists and is properly formatted.", true);
                return false;
            }
            
            // Extract study IDs from the provided data, now with abstract_ prefix
            studyIds = rawData.abstract_study_ids;
            // Cache original study IDs
            originalStudyIds = [...studyIds];
            
            // Store study details for tooltips if available
            studyDetailsCache = rawData.study_details || {};
            
            debug("Extracted study IDs", { count: studyIds.length, first: studyIds[0], last: studyIds[studyIds.length-1] });
            
            if (studyIds.length === 0) {
                showStatus("No study IDs found in the similarity data.", true);
                return false;
            }
            
            // Process the similarity matrix, now with abstract_ prefix
            similarityMatrix = rawData.abstract_matrix || [];
            // Cache original similarity matrix (deep copy)
            originalSimilarityMatrix = similarityMatrix.map(row => [...row]);
            
            debug("Processed similarity matrix", { rows: similarityMatrix.length });
            
            if (similarityMatrix.length === 0) {
                showStatus("Could not process similarity data. Matrix is empty.", true);
                return false;
            }
            
            return true;
        } catch (error) {
            console.error("Error processing similarity data:", error);
            debug("Error processing similarity data", error.toString());
            showStatus(`Error processing similarity data: ${error.message}`, true);
            return false;
        }
    }
    
    // Wait for the page to fully load before initializing
    window.addEventListener('load', function() {
        // Short delay to ensure DOM is fully laid out
        setTimeout(function() {
            const container = document.getElementById('graphContainer');
            
            // Force layout recalculation
            container.style.width = '100%';
            container.style.display = 'block';
            
            // Force the browser to calculate the layout by accessing offsetWidth
            const forceReflow = container.offsetWidth;
            debug("Initial load - forcing container width calculation:", forceReflow);
            
            // Now initialize
            initializeVisualization();
        }, 500); // Longer delay to ensure DOM is fully rendered
    });
    
    // Initialize the visualization when the tab becomes visible
    document.addEventListener('DOMContentLoaded', function() {
        debug("DOM loaded");
        
        // Process data
        if (!processSimilarityData()) {
            return; // Exit if data processing failed
        }

        // Populate the color category dropdown
        populateColorCategoryDropdown();
        
        // Add event listener for the color category dropdown
        document.getElementById('similarityColorCategory').addEventListener('change', function() {
            updateNodeColors();
        });
        
        // Create slider
        try {
            const sliderElement = document.getElementById('thresholdSlider');
            
            noUiSlider.create(sliderElement, {
                start: [1], // Default to 1 steddev
                connect: [true, false], // Connect to the left
                range: {
                    'min': -3, // Typically -3 standard deviations
                    'max': 3   // Typically +3 standard deviations
                },
                step: 0.1,
                tooltips: [true], // Show tooltip
                format: {
                    to: function (value) {
                        return value.toFixed(2);
                    },
                    from: function (value) {
                        return parseFloat(value);
                    }
                }
            });
            
            // Update visualization when slider changes
            sliderElement.noUiSlider.on('update', function (values, handle) {
                const threshold = parseFloat(values[handle]);
                document.getElementById('thresholdValue').textContent = threshold.toFixed(2);
                document.getElementById('thresholdValue').classList.add('threshold-value-display');
                
                // Only update visualization if it's been initialized
                if (svg) {
                    updateVisualization(threshold);
                }
            });
        } catch (error) {
            console.error("Error creating slider:", error);
            debug("Error creating slider", error.toString());
            showStatus(`Error initializing controls: ${error.message}`, true);
        }
        
        // Setup tooltip
        tooltip = d3.select("body").append("div")
            .attr("class", "tooltip")
            .style("opacity", 0);
        
        // Add visibility change detection - important for tabs
        document.addEventListener('visibilitychange', handleVisibilityChange);
        
        // Add event listeners for tab switching in the parent page
        document.querySelectorAll('.navbar-item').forEach(navItem => {
            navItem.addEventListener('click', function() {
                // If this is the similarity view tab
                if (this.getAttribute('data-section') === 'similarityView') {
                    // Force layout calculation and initialize visualization
                    setTimeout(function() {
                        const container = document.getElementById('graphContainer');
                        container.style.width = '100%';
                        const forceReflow = container.offsetWidth;
                        debug("Tab switch - forcing container width calculation:", forceReflow);
                        initializeVisualization();
                    }, 300);
                }
            });
        });
        
        // Listen for window resize events with a proper debounce
        window.addEventListener('resize', debounce(function() {
            const container = document.getElementById('graphContainer');
            // Only reinitialize if the graph container is visible
            if (container.offsetParent !== null) {
                debug("Window resize - reinitializing visualization");
                initializeVisualization();
            }
        }, 250));

        // Initialize the connections modal
        connectionsModal = new bootstrap.Modal(document.getElementById('connectionsModal'));
        
        // Handle modal interactions
        document.getElementById('infoModal').addEventListener('show.bs.modal', function() {
            const connectionsModalElement = document.getElementById('connectionsModal');
            if (connectionsModalElement && connectionsModalElement.classList.contains('show')) {
                connectionsModalElement.classList.add('transparent-background-modal');
            }
        });
        
        document.getElementById('infoModal').addEventListener('hidden.bs.modal', function() {
            const connectionsModalElement = document.getElementById('connectionsModal');
            if (connectionsModalElement) {
                connectionsModalElement.classList.remove('transparent-background-modal');
            }
        });
    });

    // Modified function to create a color legend without parenthetical content for specific fields
    function createColorLegend() {
        try {
            // Remove any existing legend
            d3.select("#colorLegend").remove();
            
            const category = document.getElementById('similarityColorCategory').value;
            
            // Only create legend if a category is selected
            if (!category || !currentColorScale) {
                return;
            }
            
            // Fields that should have parentheticals removed (from app.py)
            const parentheticalRemovalFields = [
                'Interaction_PANEL_Accuracy of Interaction Recognition',
                'Interaction_PANEL_Robustness of Interaction Detection',
                'Study_PANEL_Elicitation Study',
                'Study_PANEL_Usability Evaluations',
                'Study_PANEL_Cognitive Ease Evaluations',
                'Study_PANEL_Discreetness of Interactions Evaluations',
                'Study_PANEL_Social Acceptability of Interactions Evaluations',
                'Study_PANEL_Accuracy of Interactions Evaluations',
                'Study_PANEL_Alternative Interaction Validity Evaluations'
            ];
            
            // Should we remove parentheticals for this category?
            const shouldRemoveParenthetical = parentheticalRemovalFields.includes(category);
            
            // Collect unique individual values for the selected category
            const valueSet = new Set();
            
            // Go through all studies to collect unique values for this category
            for (const studyId in studyDetailsCache) {
                const study = studyDetailsCache[studyId];
                
                // Skip if study is not an object
                if (!study || typeof study !== 'object') continue;
                
                // Get the value for this category
                let value = study[category];
                
                // Skip if value is undefined or null
                if (value === undefined || value === null) continue;
                
                // Convert to string and trim
                value = String(value).trim();
                
                if (!value) continue;
                
                // Handle comma-separated values - add each individual value to the set
                if (value.includes(',')) {
                    value.split(',').forEach(v => {
                        const trimmed = v.trim();
                        if (trimmed) {
                            // Remove parentheticals if required
                            if (shouldRemoveParenthetical && trimmed.includes('(')) {
                                const baseValue = trimmed.split('(')[0].trim();
                                valueSet.add(baseValue);
                            } else {
                                valueSet.add(trimmed);
                            }
                        }
                    });
                } else {
                    // Remove parentheticals if required
                    if (shouldRemoveParenthetical && value.includes('(')) {
                        const baseValue = value.split('(')[0].trim();
                        valueSet.add(baseValue);
                    } else {
                        valueSet.add(value);
                    }
                }
            }
            
            // Get all unique individual values
            let uniqueValues = Array.from(valueSet);
            
            // Apply custom sort logic
            const specialOrders = {
                'Yes': 1, 'Partly': 2, 'No': 3, 
                'Low': 1, 'Medium': 2, 'High': 3, 
                'Semantic': 1, 'Coarse': 2, 'Fine': 3, 'N/A': 4, 
                'Yes (Performance Loss)': 2, 'Visual Attention': 2
            };
            
            uniqueValues.sort((a, b) => {
                // Check if this is the Number of Selected Gestures field
                if (category === "Interaction_PANEL_Number of Selected Gestures") {
                    // Parse as numbers for numeric comparison
                    return parseFloat(a) - parseFloat(b);
                }
                
                // Use special order for specific values
                const orderA = specialOrders[a] || 0;
                const orderB = specialOrders[b] || 0;
                
                // First sort by special order
                if (orderA !== orderB) {
                    return orderA - orderB;
                }
                
                // Then sort alphabetically
                return a.toLowerCase().localeCompare(b.toLowerCase());
            });
            
            // Create legend container after the graph container
            const legend = d3.select("#similarityContainer")
                .append("div")
                .attr("id", "colorLegend")
                .style("display", "flex")
                .style("flex-wrap", "wrap")
                .style("justify-content", "center")
                .style("background", "rgba(255, 255, 255, 0.9)")
                .style("border", "1px solid #ddd")
                .style("border-radius", "4px")
                .style("padding", "12px")
                .style("margin-top", "15px")
                .style("margin-bottom", "15px")
                .style("font-size", "13px")
                .style("box-shadow", "0px 0px 5px rgba(0, 0, 0, 0.1)");
                    
            // Add title that spans the full width
            legend.append("div")
                .style("width", "100%")
                .style("font-weight", "bold")
                .style("margin-bottom", "10px")
                .style("text-align", "center")
                .text(`${category.includes('_') ? category.split('_').pop() : category}`);
                
            // Add note about multi-values
            legend.append("div")
                .style("width", "100%")
                .style("font-style", "italic")
                .style("margin-bottom", "10px")
                .style("text-align", "center")
                .style("font-size", "11px")
                .text("Note: Studies with multiple values are shown as pie charts");
                
            // Add legend items in a flex container
            const legendItems = legend.append("div")
                .style("display", "flex")
                .style("flex-wrap", "wrap")
                .style("justify-content", "center")
                .style("gap", "15px");
                
            // Add legend items in the sorted order
            uniqueValues.forEach(value => {
                const item = legendItems.append("div")
                    .style("display", "flex")
                    .style("align-items", "center")
                    .style("margin-bottom", "5px")
                    .style("margin-right", "5px");
                    
                // Color square
                item.append("div")
                    .style("width", "14px")
                    .style("height", "14px")
                    .style("background", currentColorScale(value))
                    .style("border", "1px solid #ddd")
                    .style("margin-right", "5px");
                    
                // Value label
                item.append("div")
                    .text(value);
            });
                
        } catch (error) {
            console.error("Error creating color legend:", error);
            debug("Error creating color legend", error.toString());
        }
    }
    
    // Also update the handleVisibilityChange function to be more aggressive
    function handleVisibilityChange() {
        if (document.visibilityState === 'visible') {
            // If the document becomes visible and the container is visible
            const similarityView = document.getElementById('similarityView');
            if (similarityView && similarityView.style.display !== 'none') {
                // Force layout calculation and initialize visualization
                setTimeout(function() {
                    const container = document.getElementById('graphContainer');
                    container.style.width = '100%';
                    const forceReflow = container.offsetWidth;
                    debug("Visibility change - forcing container width calculation:", forceReflow);
                    initializeVisualization();
                }, 300);
            }
        }
    }

    function populateColorCategoryDropdown() {
    try {
        const dropdown = document.getElementById('similarityColorCategory');
        
        // Clear existing options, keeping only the default
        while (dropdown.options.length > 1) {
            dropdown.remove(1);
        }
        
        // Check if we have study details data
        if (Object.keys(studyDetailsCache).length === 0) {
            debug("No study details available for categories");
            return;
        }
        
        // Define the column order based on the CSV file structure
        // This follows the exact order from the data.csv file
        const columnOrder = [
            "Location",
            "Input Body Part",
            "Sensing_PANEL_Sensors",
            "Sensing_PANEL_No Additional Sensing",
            "Interaction_PANEL_Number of Selected Gestures",
            "Interaction_PANEL_Resolution",
            "Interaction_PANEL_Hands-Free",
            "Interaction_PANEL_Eyes-Free",
            "Interaction_PANEL_Possible on One Ear",
            "Interaction_PANEL_Adaptation of the Interaction Detection Algorithm to the Individual User",
            "Interaction_PANEL_Discreetness of Interaction Techniques",
            "Interaction_PANEL_Social Acceptability of Interaction Techniques",
            "Interaction_PANEL_Accuracy of Interaction Recognition",
            "Interaction_PANEL_Robustness of Interaction Detection",
            "Study_PANEL_Elicitation Study",
            "Study_PANEL_Usability Evaluations",
            "Study_PANEL_Cognitive Ease Evaluations",
            "Study_PANEL_Discreetness of Interactions Evaluations",
            "Study_PANEL_Social Acceptability of Interactions Evaluations",
            "Study_PANEL_Accuracy of Interactions Evaluations",
            "Study_PANEL_Alternative Interaction Validity Evaluations",
            "Study_PANEL_Evaluation of Different Conditions",
            "Study_PANEL_Evaluation of Different Settings",
            "Device_PANEL_Earphone Type",
            "Device_PANEL_Development Stage",
            "Device_PANEL_Real-Time Processing",
            "Device_PANEL_On-Device Processing",
            "Applications_PANEL_Intended Applications"
        ];
        
        // Filter the columns to only include those available in the dataset
        const availableColumns = [];
        
        // Go through the ordered columns and check if they exist in the data
        for (const column of columnOrder) {
            // Check if this column exists in at least one study
            let columnExists = false;
            for (const studyId in studyDetailsCache) {
                if (studyDetailsCache[studyId] && 
                    studyDetailsCache[studyId][column] !== undefined) {
                    columnExists = true;
                    break;
                }
            }
            
            if (columnExists) {
                availableColumns.push(column);
            }
        }
        
        // Add options to dropdown in the specified order
        availableColumns.forEach(category => {
            const option = document.createElement('option');
            option.value = category;  // Keep the full value for internal use
            
            // Display only the part after the last underscore
            const displayName = category.includes('_') ? 
                category.split('_').pop() : category;
            
            option.textContent = displayName;
            dropdown.appendChild(option);
        });
        
        debug("Color category dropdown populated with options", { 
            optionCount: availableColumns.length, 
            categories: availableColumns 
        });
        
    } catch (error) {
        console.error("Error populating color category dropdown:", error);
        debug("Error populating color category dropdown", error.toString());
    }
}

    // Function to generate a color scale for category values with parenthetical handling
    function generateColorScale(category) {
        try {
            // Fields that should have parentheticals removed (from app.py)
            const parentheticalRemovalFields = [
                'Interaction_PANEL_Accuracy of Interaction Recognition',
                'Interaction_PANEL_Robustness of Interaction Detection',
                'Study_PANEL_Elicitation Study',
                'Study_PANEL_Usability Evaluations',
                'Study_PANEL_Cognitive Ease Evaluations',
                'Study_PANEL_Discreetness of Interactions Evaluations',
                'Study_PANEL_Social Acceptability of Interactions Evaluations',
                'Study_PANEL_Accuracy of Interactions Evaluations',
                'Study_PANEL_Alternative Interaction Validity Evaluations'
            ];
            
            // Should we remove parentheticals for this category?
            const shouldRemoveParenthetical = parentheticalRemovalFields.includes(category);
            
            // Collect unique values for the selected category
            const allValues = [];
            const uniqueValues = new Set();
            
            // Go through all studies to collect unique values for this category
            for (const studyId in studyDetailsCache) {
                const study = studyDetailsCache[studyId];
                
                // Skip if study is not an object
                if (!study || typeof study !== 'object') continue;
                
                // Get the value for this category
                let value = study[category];
                
                // Skip if value is undefined or null
                if (value === undefined || value === null) continue;
                
                // Convert to string and trim
                value = String(value).trim();
                
                // Add non-empty values to the map
                if (value) {
                    // Handle comma-separated values
                    if (value.includes(',')) {
                        value.split(',').forEach(v => {
                            const trimmed = v.trim();
                            if (trimmed) {
                                if (shouldRemoveParenthetical && trimmed.includes('(')) {
                                    const baseValue = trimmed.split('(')[0].trim();
                                    allValues.push(baseValue);
                                    uniqueValues.add(baseValue);
                                } else {
                                    allValues.push(trimmed);
                                    uniqueValues.add(trimmed);
                                }
                            }
                        });
                    } else {
                        if (shouldRemoveParenthetical && value.includes('(')) {
                            const baseValue = value.split('(')[0].trim();
                            allValues.push(baseValue);
                            uniqueValues.add(baseValue);
                        } else {
                            allValues.push(value);
                            uniqueValues.add(value);
                        }
                    }
                }
            }
            
            // Convert set to array
            const cleanedValues = Array.from(uniqueValues);
            
            // Apply custom sort logic to clean values
            const specialOrders = {
                'Yes': 1, 'Partly': 2, 'No': 3, 
                'Low': 1, 'Medium': 2, 'High': 3, 
                'Semantic': 1, 'Coarse': 2, 'Fine': 3, 'N/A': 4, 
                'Yes (Performance Loss)': 2, 'Visual Attention': 2
            };
            
            cleanedValues.sort((a, b) => {
                // Check if this is the Number of Selected Gestures field
                if (category === "Interaction_PANEL_Number of Selected Gestures") {
                    // Parse as numbers for numeric comparison
                    return parseFloat(a) - parseFloat(b);
                }
                
                const orderA = specialOrders[a] || 0;
                const orderB = specialOrders[b] || 0;
                
                // First sort by special order
                if (orderA !== orderB) {
                    return orderA - orderB;
                }
                
                // Then sort alphabetically
                return a.toLowerCase().localeCompare(b.toLowerCase());
            });
            
            // Define the custom color palette
            const chartColorPalette = ['#d1615d', '#5778a4', '#6a9f58', '#e49444', '#85b6b2', '#e7ca60', '#a87c9f', '#f1a2a9', '#967662', '#b8b0ac'];
            
            // Create an extended palette by duplicating and brightening the colors
            const extendedPalette = [...chartColorPalette];
            
            // Add brightened versions of each color
            chartColorPalette.forEach(color => {
                // Parse the hex color
                const rgb = d3.color(color);
                
                // Brighten the color by increasing lightness
                rgb.opacity = 0.9;  // Make slightly transparent
                const brighter = d3.color(rgb.brighter(0.7)); // Make brighter
                
                // Add the brightened color to our extended palette
                extendedPalette.push(brighter.toString());
            });
            
            // Add darker versions of each color (for options 21-30)
            chartColorPalette.forEach(color => {
                // Parse the hex color
                const rgb = d3.color(color);
                
                // Darken the color
                rgb.opacity = 1.0;  // Full opacity for darker colors
                const darker = d3.color(rgb.darker(0.7)); // Make darker
                
                // Add the darkened color to our extended palette
                extendedPalette.push(darker.toString());
            });
            
            // Generate a color scale based on the number of unique values
            let colorScale;
            
            if (cleanedValues.length <= 10) {
                // Use original color palette if we have 10 or fewer values
                colorScale = d3.scaleOrdinal()
                    .domain(cleanedValues)
                    .range(chartColorPalette.slice(0, cleanedValues.length));
            } else if (cleanedValues.length <= 20) {
                // If 11-20 values, use the extended palette with bright colors
                colorScale = d3.scaleOrdinal()
                    .domain(cleanedValues)
                    .range(extendedPalette.slice(0, cleanedValues.length));
            } else if (cleanedValues.length <= 30) {
                // If 21-30 values, use the extended palette with all 30 colors
                colorScale = d3.scaleOrdinal()
                    .domain(cleanedValues)
                    .range(extendedPalette.slice(0, cleanedValues.length));
            } else {
                // If more than 30 values, cycle through the palette
                colorScale = d3.scaleOrdinal()
                    .domain(cleanedValues)
                    .range(Array.from({ length: cleanedValues.length }, (_, i) => 
                        extendedPalette[i % extendedPalette.length]));
            }
            
            debug("Generated color scale for category", { 
                category, 
                uniqueValues: cleanedValues.length,
                paletteSize: colorScale.range().length
            });
            
            return colorScale;
            
        } catch (error) {
            console.error("Error generating color scale:", error);
            debug("Error generating color scale", error.toString());
            
            // Return a default color function that always returns the same color
            return () => "#B89491";
        }
    }

    // Modified function to get node color based on selected category
    function getNodeColor(node) {
        // If no category is selected, use default color
        if (!currentColorScale) {
            return "#B89491";
        }
        
        const studyId = node.id;
        const study = studyDetailsCache[studyId];
        
        // If study doesn't exist, use default color
        if (!study) return "#B89491";
        
        const category = document.getElementById('similarityColorCategory').value;
        let rawValue = study[category];
        
        // If value is undefined, use default color
        if (rawValue === undefined || rawValue === null || rawValue === "") {
            return "#cccccc"; // Light gray for missing values
        }
        
        // Fields that should have parentheticals removed (from app.py)
        const parentheticalRemovalFields = [
            'Interaction_PANEL_Accuracy of Interaction Recognition',
            'Interaction_PANEL_Robustness of Interaction Detection',
            'Study_PANEL_Elicitation Study',
            'Study_PANEL_Usability Evaluations',
            'Study_PANEL_Cognitive Ease Evaluations',
            'Study_PANEL_Discreetness of Interactions Evaluations',
            'Study_PANEL_Social Acceptability of Interactions Evaluations',
            'Study_PANEL_Accuracy of Interactions Evaluations',
            'Study_PANEL_Alternative Interaction Validity Evaluations'
        ];
        
        // Should we remove parentheticals for this category?
        const shouldRemoveParenthetical = parentheticalRemovalFields.includes(category);
        
        // Check if the value contains multiple options (comma-separated)
        if (typeof rawValue === 'string' && rawValue.includes(',')) {
            // Split the value by commas and trim each value
            const values = rawValue.split(',').map(v => v.trim()).filter(v => v);
            
            // If we have multiple values after splitting, return an array of colors
            if (values.length > 1) {
                return values.map(val => {
                    // Process each value to remove parentheticals if needed
                    if (shouldRemoveParenthetical && val.includes('(')) {
                        // Get the cleaned value for the color lookup
                        const baseValue = val.split('(')[0].trim();
                        // For this specific value, find the color from the color scale
                        // Look up this clean value using the color scale
                        return currentColorScale(baseValue);
                    }
                    return currentColorScale(val);
                });
            }
            
            // If only one value after splitting, use that single value
            if (values.length === 1) {
                let value = values[0];
                if (shouldRemoveParenthetical && value.includes('(')) {
                    value = value.split('(')[0].trim();
                }
                return currentColorScale(value);
            }
        } else if (shouldRemoveParenthetical && typeof rawValue === 'string' && rawValue.includes('(')) {
            // Single value with parenthetical that needs removal
            const baseValue = rawValue.split('(')[0].trim();
            // Use the cleaned value for color scale lookup
            return currentColorScale(baseValue);
        }
        
        // Single value - use the color scale to determine color
        return currentColorScale(rawValue);
    }

    // Replace the createPieNode function with our new approach
    function createPieNode(nodeSelection, d, nodeRadius) {
        // Use the pattern fill approach instead
        createPatternFill(nodeSelection, d, nodeRadius);
    }

    // Function to create a pattern fill for multi-value nodes
    function createPatternFill(nodeSelection, d, nodeRadius) {
        const colors = getNodeColor(d);
        
        // If not an array, this is a single-value node, just set the fill color directly
        if (!Array.isArray(colors) || colors.length === 1) {
            nodeSelection.style("fill", Array.isArray(colors) ? colors[0] : colors);
            return;
        }
        
        // For multi-value nodes, create a pie chart pattern
        // Make sure pattern ID is URL-safe and unique
        const patternId = `pattern-${d.id}-${Math.random().toString(36).substring(2, 10)}`.replace(/[^\w-]/g, '-');
        
        // Remove any existing patterns for this node
        d3.selectAll(`pattern[id^="pattern-${d.id}-"]`).remove();
        
        // Create a pattern definition
        const defs = svg.select("defs").empty() ? svg.append("defs") : svg.select("defs");
        
        // Create a pattern
        const pattern = defs.append("pattern")
            .attr("id", patternId)
            .attr("width", 1)
            .attr("height", 1)
            .attr("patternUnits", "objectBoundingBox")
            .attr("patternContentUnits", "objectBoundingBox");
        
        // Create a pie chart layout
        const pie = d3.pie()
            .value(() => 1)
            .sort(null)
            .padAngle(0.01);
            
        // Generate the pie segments data
        const pieData = pie(colors);
        
        // Create an arc generator for the segments
        const arc = d3.arc()
            .innerRadius(0)
            .outerRadius(0.5) // Use 0.5 since pattern coordinates are normalized (0-1)
            .padAngle(0.01);
        
        // Add a group for the pie chart with proper centering
        const pieGroup = pattern.append("g")
            .attr("transform", "translate(0.5, 0.5)"); // Center in the pattern
            
        // Add each segment to the pattern
        pieData.forEach(segment => {
            pieGroup.append("path")
                .attr("d", arc(segment))
                .style("fill", segment.data)
                .style("stroke", "#fff")
                .style("stroke-width", 0.02);
        });
        
        // Apply the pattern to the node
        nodeSelection.style("fill", `url(#${patternId})`);
    }

// Function to update node colors based on selected category
function updateNodeColors() {
    try {
        const category = document.getElementById('similarityColorCategory').value;
        
        // If no category selected, reset to default colors
        if (!category) {
            currentColorScale = null;
            d3.selectAll(".node").style("fill", "#B89491");
            // Remove any existing legend
            d3.select("#colorLegend").remove();
            return;
        }
        
        // Generate a new color scale for the selected category
        currentColorScale = generateColorScale(category);
        
        // Clear any existing patterns before creating new ones
        svg.select("defs").html("");
        
        // Re-sort and re-layout the entire visualization based on the new category
        const threshold = parseFloat(document.getElementById('thresholdValue').textContent);
        updateVisualization(threshold);
        
        // Create or update the color legend
        createColorLegend();
        
        debug("Updated node colors based on category", { category });
        
    } catch (error) {
        console.error("Error updating node colors:", error);
        debug("Error updating node colors", error.toString());
        showStatus(`Error updating node colors: ${error.message}`, true);
    }
}
    
    // Debounce function to limit frequent updates
    function debounce(func, wait) {
        let timeout;
        return function() {
            const context = this;
            const args = arguments;
            clearTimeout(timeout);
            timeout = setTimeout(() => {
                func.apply(context, args);
            }, wait);
        };
    }
    
    // Initialize the visualization container
    function initializeVisualization() {
        debug("Initializing visualization container");
        
        const container = document.getElementById('graphContainer');
        
        // Force the container to be visible and take full width
        container.style.display = 'block';
        container.style.width = '100%';
        
        // Get width from container
        width = container.offsetWidth || 800;
        
        debug("Container width measured", { width });
        
        // Calculate dynamic height based on number of studies
        // Higher threshold for U-shape layout (>50 studies)
        const useULayout = studyIds.length > 50;
        
        // Calculate appropriate height based on number of studies and layout type
        let calculatedHeight;
        if (useULayout) {
            // For U-shape, calculate based on number of studies and spacing
            calculatedHeight = Math.max(500, Math.min(800, studyIds.length * 12));
        } else {
            // For standard layout, less height needed
            calculatedHeight = Math.max(400, Math.min(600, studyIds.length * 8));
        }
        
        // Set height for this visualization
        height = calculatedHeight;
        debug("Dynamic height calculated", { height });
        
        // Clear container
        d3.select("#graphContainer").html("");
        
        // Create SVG with calculated dimensions
        svg = d3.select("#graphContainer").append("svg")
            .attr("width", width)
            .attr("height", height)
            .style("display", "block"); // Ensure block display
            
        // Create a container group
        svg.append("g")
            .attr("class", "viz-layer");
        
        // Initialize with current threshold
        const threshold = parseFloat(document.getElementById('thresholdValue').textContent || "0");
        updateVisualization(threshold);
        
        debug("Visualization initialized with dimensions", { 
            width, 
            height,
            threshold 
        });
    }

    // Add this function to sort nodes based on the selected category
    function sortNodesByCategory(nodes) {
        const category = document.getElementById('similarityColorCategory').value;
        
        // If no category is selected, return original order (by ID)
        if (!category || !currentColorScale) {
            return nodes;
        }
        
        // Fields that should have parentheticals removed
        const parentheticalRemovalFields = [
            'Interaction_PANEL_Accuracy of Interaction Recognition',
            'Interaction_PANEL_Robustness of Interaction Detection',
            'Study_PANEL_Elicitation Study',
            'Study_PANEL_Usability Evaluations',
            'Study_PANEL_Cognitive Ease Evaluations',
            'Study_PANEL_Discreetness of Interactions Evaluations',
            'Study_PANEL_Social Acceptability of Interactions Evaluations',
            'Study_PANEL_Accuracy of Interactions Evaluations',
            'Study_PANEL_Alternative Interaction Validity Evaluations'
        ];
        
        // Should we remove parentheticals for this category?
        const shouldRemoveParenthetical = parentheticalRemovalFields.includes(category);
        
        // Get the unique values in the order they appear in the legend
        const legendValues = [];
        const valueSet = new Set();
        
        // Collect unique individual values for the selected category
        for (const studyId in studyDetailsCache) {
            const study = studyDetailsCache[studyId];
            if (!study || typeof study !== 'object') continue;
            
            let value = study[category];
            if (value === undefined || value === null) continue;
            
            value = String(value).trim();
            if (!value) continue;
            
            // Handle comma-separated values
            if (value.includes(',')) {
                value.split(',').forEach(v => {
                    const trimmed = v.trim();
                    if (trimmed) {
                        if (shouldRemoveParenthetical && trimmed.includes('(')) {
                            const baseValue = trimmed.split('(')[0].trim();
                            if (!valueSet.has(baseValue)) {
                                valueSet.add(baseValue);
                                legendValues.push(baseValue);
                            }
                        } else {
                            if (!valueSet.has(trimmed)) {
                                valueSet.add(trimmed);
                                legendValues.push(trimmed);
                            }
                        }
                    }
                });
            } else {
                if (shouldRemoveParenthetical && value.includes('(')) {
                    const baseValue = value.split('(')[0].trim();
                    if (!valueSet.has(baseValue)) {
                        valueSet.add(baseValue);
                        legendValues.push(baseValue);
                    }
                } else {
                    if (!valueSet.has(value)) {
                        valueSet.add(value);
                        legendValues.push(value);
                    }
                }
            }
        }
        
        // Sort legend values according to the same logic used in the legend
        const specialOrders = {
            'Yes': 1, 'Partly': 2, 'No': 3, 
            'Low': 1, 'Medium': 2, 'High': 3, 
            'Semantic': 1, 'Coarse': 2, 'Fine': 3, 'N/A': 4, 
            'Yes (Performance Loss)': 2, 'Visual Attention': 2
        };
        
        legendValues.sort((a, b) => {
            // Check if this is the Number of Selected Gestures field
            if (category === "Interaction_PANEL_Number of Selected Gestures") {
                // Parse as numbers for numeric comparison
                return parseFloat(a) - parseFloat(b);
            }
            
            // Use special order for specific values
            const orderA = specialOrders[a] || 0;
            const orderB = specialOrders[b] || 0;
            
            // First sort by special order
            if (orderA !== orderB) {
                return orderA - orderB;
            }
            
            // Then sort alphabetically
            return a.toLowerCase().localeCompare(b.toLowerCase());
        });
        
        // Create a function to get the value(s) for a node
        function getNodeValues(node) {
            const study = studyDetailsCache[node.id];
            if (!study) return [];
            
            let rawValue = study[category];
            if (rawValue === undefined || rawValue === null || rawValue === "") {
                return [];
            }
            
            rawValue = String(rawValue).trim();
            
            let values = [];
            if (rawValue.includes(',')) {
                values = rawValue.split(',')
                    .map(v => v.trim())
                    .filter(v => v)
                    .map(v => {
                        if (shouldRemoveParenthetical && v.includes('(')) {
                            return v.split('(')[0].trim();
                        }
                        return v;
                    });
            } else {
                if (shouldRemoveParenthetical && rawValue.includes('(')) {
                    values.push(rawValue.split('(')[0].trim());
                } else {
                    values.push(rawValue);
                }
            }
            
            return values;
        }
        
        // Copy nodes to avoid modifying the original array
        const sortedNodes = [...nodes];
        
        // Sort nodes by:
        // 1. Number of values (ascending)
        // 2. First value's position in legend
        // 3. Second value's position in legend (if any)
        // Etc.
        sortedNodes.sort((a, b) => {
            const valuesA = getNodeValues(a);
            const valuesB = getNodeValues(b);
            
            // First sort by number of values
            if (valuesA.length !== valuesB.length) {
                return valuesA.length - valuesB.length;
            }
            
            // Sort by values in order
            for (let i = 0; i < Math.min(valuesA.length, valuesB.length); i++) {
                const indexA = legendValues.indexOf(valuesA[i]);
                const indexB = legendValues.indexOf(valuesB[i]);
                
                if (indexA !== indexB) {
                    return indexA - indexB;
                }
            }
            
            // Default to ID sort if everything else is equal
            return a.id.localeCompare(b.id);
        });
        
        return sortedNodes;
    }
    
    // Generate graph data from the similarity matrix
    function generateGraphData(threshold) {
        debug(`Generating graph data with threshold: ${threshold}`);
        
        if (!studyIds.length || !similarityMatrix.length) {
            debug("No data available for graph generation");
            return { nodes: [], links: [] };
        }
        
        const nodes = studyIds.map((id, index) => ({ id, index }));
        const links = [];
        
        let connectionCount = 0;
        
        for (let i = 0; i < studyIds.length; i++) {
            for (let j = i + 1; j < studyIds.length; j++) {
                // Make sure we have data for this cell
                if (i < similarityMatrix.length && j < similarityMatrix[i].length) {
                    const similarity = similarityMatrix[i][j];
                    if (similarity && similarity >= threshold) {
                        links.push({
                            source: i,
                            target: j,
                            sourceId: studyIds[i],
                            targetId: studyIds[j],
                            value: similarity
                        });
                        connectionCount++;
                    }
                }
            }
        }
        
        debug("Graph data generated", { 
            nodeCount: nodes.length,
            linkCount: links.length,
            threshold: threshold,
            connectionCount: connectionCount
        });
        
        return { nodes, links };
    }

    // Line spacing based on screen width
let lineSpacingRatio = 0.25; // Default spacing

// Add a function to determine line spacing based on screen size
function getLineSpacingRatio() {
    // Use window width to determine spacing
    const windowWidth = window.innerWidth;
    
    if (windowWidth < 600) {
        return 0.15; // Very small spacing for small screens
    } else if (windowWidth < 800) {
        return 0.2;  // Small spacing for medium screens
    } else if (windowWidth < 1000) {
        return 0.25; // Medium spacing for larger screens
    } else if (windowWidth < 1200) {
        return 0.3;  // Larger spacing for wide screens
    } else if (windowWidth < 1400) {
        return 0.35;  // Larger spacing for wide screens
    } else if (windowWidth < 1600) {
        return 0.4;  // Larger spacing for wide screens
    } else if (windowWidth < 1800) {
        return 0.45;  // Larger spacing for wide screens
    } else {
        return 0.5; // Maximum spacing for extra wide screens
    }
}
    
function updateVisualization(threshold) {
    try {
        debug(`Updating visualization with threshold: ${threshold}`);
        
        if (!svg || width === 0) {
            debug("SVG not initialized or has zero width, aborting update");
            return;
        }
        
        // Clean up any existing patterns in defs
        svg.select("defs").html("");
        
        // Generate graph data
        let graphData = generateGraphData(threshold);
        
        if (graphData.nodes.length === 0) {
            showStatus("No nodes available to visualize.", true);
            return;
        }
        
        // Sort nodes by selected category before layout
        graphData.nodes = sortNodesByCategory(graphData.nodes);
        
        // Update links to use the new node indices after sorting
        const nodeIdToIndex = {};
        graphData.nodes.forEach((node, index) => {
            nodeIdToIndex[node.id] = index;
            // Update the index property to match its new position
            node.index = index;
        });
        
        // Update link source and target indices
        graphData.links.forEach(link => {
            const sourceId = studyIds[link.source];
            const targetId = studyIds[link.target];
            link.source = nodeIdToIndex[sourceId];
            link.target = nodeIdToIndex[targetId];
        });
        
        // Rest of the function remains the same...
        
        // Clear previous visualization
        d3.select(".viz-layer").html("");
        
        const container = d3.select(".viz-layer");
        
        // Determine if we should use the U-shaped layout (when node count > 50)
        const useULayout = graphData.nodes.length > 50;
        
        // Set layout parameters based on layout type
        const nodeRadius = 8;
        const padding = width * 0.05; // 5% padding on each side
        const lineWidth = Math.max(width - (padding * 2), 1); // Ensure positive width
        
        if (!useULayout) {
            // Standard horizontal line layout
            const lineY = height / 2;
            
            // Draw a horizontal line
            container.append("line")
                .attr("x1", padding)
                .attr("y1", lineY)
                .attr("x2", width - padding)
                .attr("y2", lineY)
                .style("stroke", "#ccc")
                .style("stroke-width", 2);
            
            // Calculate node positions along the line
            const nodeStep = graphData.nodes.length <= 1 ? 0 : lineWidth / (graphData.nodes.length - 1);
            
            // Draw links, nodes, and labels for standard layout
            drawStandardLayout(container, graphData, lineY, nodeStep, padding, nodeRadius);
            
        } else {
            // Adjust the spacing based on available height
            const lineSpacing = getLineSpacingRatio();            const topLineY = height * (0.5 - lineSpacing/2); // Dynamic positioning
            const bottomLineY = height * (0.5 + lineSpacing/2); // Dynamic positioning
            
            const halfNodeCount = Math.ceil(graphData.nodes.length / 2);
            
            // Draw top horizontal line
            container.append("line")
                .attr("x1", padding)
                .attr("y1", topLineY)
                .attr("x2", width - padding)
                .attr("y2", topLineY)
                .style("stroke", "#ccc")
                .style("stroke-width", 2);
                
            // Draw bottom horizontal line
            container.append("line")
                .attr("x1", padding)
                .attr("y1", bottomLineY)
                .attr("x2", width - padding)
                .attr("y2", bottomLineY)
                .style("stroke", "#ccc")
                .style("stroke-width", 2);
                
            // Draw connecting curves on the sides
            /*
            container.append("path")
                .attr("d", `M ${padding},${topLineY} Q ${padding - width * 0.05},${height/2} ${padding},${bottomLineY}`)
                .style("stroke", "#ccc")
                .style("fill", "none")
                .style("stroke-width", 2);
                
            container.append("path")
                .attr("d", `M ${width - padding},${topLineY} Q ${width - padding + width * 0.05},${height/2} ${width - padding},${bottomLineY}`)
                .style("stroke", "#ccc")
                .style("fill", "none")
                .style("stroke-width", 2); */
                
            // Calculate node steps for top and bottom
            const nodeStep = lineWidth / (Math.max(halfNodeCount, 1) - 1);
            
            // Draw links, nodes, and labels for U layout
            drawUShapedLayout(container, graphData, topLineY, bottomLineY, nodeStep, padding, nodeRadius, halfNodeCount);
        }
        
        // Show a message if there are no connections at this threshold
        if (graphData.links.length === 0) {
            container.append("text")
                .attr("x", width / 2)
                .attr("y", height / 2 - 100)
                .style("text-anchor", "middle")
                .style("font-size", "14px")
                .style("fill", "#721c24")
                .text("No connections found at the current threshold. Try lowering the threshold value.");
        }
        
        debug("Visualization updated", {
            nodeCount: graphData.nodes.length,
            linkCount: graphData.links.length,
            threshold: threshold,
            layout: useULayout ? "U-shaped" : "Standard"
        });
    
        // Force patterns to be drawn immediately for all nodes
        setTimeout(() => {
            const nodes = d3.selectAll(".node");
            nodes.each(function(d) {
                const nodeRadius = parseFloat(d3.select(this).attr("r")) || 8;
                createPatternFill(d3.select(this), d, nodeRadius);
            });
        }, 100);
        
    } catch (error) {
        console.error("Error updating visualization:", error);
        debug("Error updating visualization", error.toString());
        showStatus(`Error updating visualization: ${error.message}`, true);
    }
}

// Helper function to draw standard horizontal layout
function drawStandardLayout(container, graphData, lineY, nodeStep, padding, nodeRadius) {
    // Create a group for curves (arcs/links) to be drawn below nodes
    const linkGroup = container.append("g").attr("class", "links");
    
    // Draw links (keep existing code)
    linkGroup.selectAll("path")
        .data(graphData.links)
        .enter().append("path")
        .attr("class", "link")
        .style("stroke", "#999")
        .style("stroke-width", 1)
        .style("stroke-opacity", 0.6)
        .attr("d", d => {
            const sourceX = padding + d.source * nodeStep;
            const targetX = padding + d.target * nodeStep;
            const arcHeight = Math.min(Math.abs(d.source - d.target) * 15, height / 3);
            return `M ${sourceX},${lineY} Q ${(sourceX + targetX) / 2},${lineY - arcHeight} ${targetX},${lineY}`;
        })
        .on("mouseover", function(event, d) {
            // Existing mouseover handler
        })
        .on("mouseout", function(event, d) {
            // Existing mouseout handler
        });
    
    // Create node group to ensure nodes are drawn on top of links
    const nodeGroup = container.append("g").attr("class", "nodes");
    
    // Draw nodes with multi-value support
    const nodes = nodeGroup.selectAll("circle")
        .data(graphData.nodes)
        .enter().append("circle")
        .attr("class", "node")
        .attr("r", nodeRadius)
        .attr("cx", (d, i) => padding + i * nodeStep)
        .attr("cy", lineY)
        .style("stroke", "#fff")
        .style("stroke-width", 1.5)
        .each(function(d) {
            // Apply either single color or pie chart
            createPieNode(d3.select(this), d, nodeRadius);
        });
    
    // Add event handlers to nodes
    addNodeEventHandlers(nodes, graphData, linkGroup, nodeGroup, nodeRadius);
    
    // Draw labels (same as before)
    nodeGroup.selectAll("text")
        .data(graphData.nodes)
        .enter().append("text")
        .attr("class", "node-label")
        .each(function(d, i) {
            // Add labels with the info icon, etc.
            addNodeLabel(d3.select(this), d);
        })
        .attr("x", (d, i) => padding + i * nodeStep)
        .attr("y", lineY + nodeRadius + 15)  // Position text 15px below the node
        .attr("transform", (d, i) => `rotate(270, ${padding + i * nodeStep}, ${lineY + nodeRadius + 15})`)
        .style("font-size", "10px")
        .style("text-anchor", "end")
        .style("dominant-baseline", "middle")
        .style("pointer-events", "all");
    
    // Add click handlers to info icons
    addInfoIconClickHandlers();
}

// Helper function to update the drawUShapedLayout function
function drawUShapedLayout(container, graphData, topLineY, bottomLineY, nodeStep, padding, nodeRadius, halfNodeCount) {
    // Create a group for curves (arcs/links)
    const linkGroup = container.append("g").attr("class", "links");
    
    // Draw links (keep existing code)
    linkGroup.selectAll("path")
        .data(graphData.links)
        .enter().append("path")
        .attr("class", "link")
        .style("stroke", "#999")
        .style("stroke-width", 1) 
        .style("stroke-opacity", 0.6)
        .attr("d", d => {
            // Existing path drawing code
        })
        .on("mouseover", function(event, d) {
            // Existing mouseover handler
        })
        .on("mouseout", function(event, d) {
            // Existing mouseout handler
        });
    
    // Create node group
    const nodeGroup = container.append("g").attr("class", "nodes");
    
    // Draw nodes with multi-value support
    const nodes = nodeGroup.selectAll("circle")
        .data(graphData.nodes)
        .enter().append("circle")
        .attr("class", "node")
        .attr("r", nodeRadius)
        .attr("cx", (d, i) => {
            if (i < halfNodeCount) {
                // First half goes on top line
                return padding + i * nodeStep;
            } else {
                // Second half goes on bottom line
                return padding + (i - halfNodeCount) * nodeStep;
            }
        })
        .attr("cy", (d, i) => i < halfNodeCount ? topLineY : bottomLineY)
        .style("stroke", "#fff")
        .style("stroke-width", 1.5)
        .each(function(d) {
            // Apply either single color or pie chart
            createPieNode(d3.select(this), d, nodeRadius);
        });
    
    // Add event handlers to nodes
    addNodeEventHandlers(nodes, graphData, linkGroup, nodeGroup, nodeRadius);
    
    // Draw labels (same as before)
    nodeGroup.selectAll("text")
        .data(graphData.nodes)
        .enter().append("text")
        .attr("class", "node-label")
        .each(function(d, i) {
            // Add labels with the info icon
            addNodeLabel(d3.select(this), d);
        })
        .attr("x", (d, i) => {
            if (i < halfNodeCount) {
                // First half on top
                return padding + i * nodeStep;
            } else {
                // Second half on bottom
                return padding + (i - halfNodeCount) * nodeStep;
            }
        })
        .attr("y", (d, i) => {
            if (i < halfNodeCount) {
                // Labels ABOVE top nodes
                return topLineY - nodeRadius - 15;
            } else {
                // Labels BELOW bottom nodes
                return bottomLineY + nodeRadius + 15;
            }
        })
        .attr("transform", (d, i) => {
            const x = i < halfNodeCount 
                ? padding + i * nodeStep 
                : padding + (i - halfNodeCount) * nodeStep;
                
            const y = i < halfNodeCount 
                ? topLineY - nodeRadius - 15 // Above top line
                : bottomLineY + nodeRadius + 15; // Below bottom line
                
            // Rotate labels differently based on position
            return i < halfNodeCount 
                ? `rotate(270, ${x}, ${y})` // Top line rotation
                : `rotate(270, ${x}, ${y})`; // Bottom line rotation
        })
        .style("font-size", "10px")
        .style("text-anchor", (d, i) => i < halfNodeCount ? "start" : "end")
        .style("dominant-baseline", "middle")
        .style("pointer-events", "all");
        
    // Add click handlers to info icons
    addInfoIconClickHandlers();
}

// Helper function to highlight connections when hovering over a node
function highlightConnections(node, graphData) {
    try {
        // Step 1: Find all connected links and nodes
        const connectedNodeIndices = new Set();
        const connectedLinkIndices = new Set();

        // Add the current node to the set of highlighted nodes
        connectedNodeIndices.add(node.index);
        
        // Find all links and connected nodes
        graphData.links.forEach((link, linkIndex) => {
            // Handle both possible D3 representations (direct indices or objects)
            const sourceIndex = typeof link.source === 'object' ? link.source.index : link.source;
            const targetIndex = typeof link.target === 'object' ? link.target.index : link.target;
            
            // Check if this node is part of the link
            if (sourceIndex === node.index) {
                // This node is the source
                connectedNodeIndices.add(targetIndex);
                connectedLinkIndices.add(linkIndex);
            } else if (targetIndex === node.index) {
                // This node is the target
                connectedNodeIndices.add(sourceIndex);
                connectedLinkIndices.add(linkIndex);
            }
        });

        // Step 2: Apply highlighting to links
        d3.selectAll(".link")
            .style("stroke", (_, i) => connectedLinkIndices.has(i) ? "#B89491" : "#999")
            .style("stroke-opacity", (_, i) => connectedLinkIndices.has(i) ? 1 : 0.3)
            .style("stroke-width", (_, i) => connectedLinkIndices.has(i) ? 1.5 : 1);
        
        // Step 3: Apply highlighting to nodes
        d3.selectAll(".node")
            .style("opacity", (d) => connectedNodeIndices.has(d.index) ? 1 : 0.3);
        
        // Step 4: Apply highlighting to labels
        d3.selectAll(".node-label")
            .style("opacity", (d) => connectedNodeIndices.has(d.index) ? 1 : 0.3);
            
    } catch (error) {
        console.error("Error in highlightConnections:", error);
        // In case of error, reset everything to visible
        d3.selectAll(".link").style("stroke", "#999").style("stroke-opacity", 0.6).style("stroke-width", 1);
        d3.selectAll(".node").style("opacity", 1);
        d3.selectAll(".node-label").style("opacity", 1);
    }
}

// Helper function to check if two nodes are connected - use this with caution as we now use the index-based approach above
function isConnected(a, b, data) {
    if (a.index === b.index) return true;
    
    return data.links.some(l => {
        // Handle both possible representations of source/target
        const sourceIndex = typeof l.source === 'object' ? l.source.index : l.source;
        const targetIndex = typeof l.target === 'object' ? l.target.index : l.target;
        
        return (sourceIndex === a.index && targetIndex === b.index) || 
               (sourceIndex === b.index && targetIndex === a.index);
    });
}


// Helper function to draw U-shaped layout
function drawUShapedLayout(container, graphData, topLineY, bottomLineY, nodeStep, padding, nodeRadius, halfNodeCount) {
    // Create a group for curves (arcs/links) to be drawn below nodes
    const linkGroup = container.append("g").attr("class", "links");
    
    // Draw links with updated path calculations for U layout
    linkGroup.selectAll("path")
        .data(graphData.links)
        .enter().append("path")
        .attr("class", "link")
        .style("stroke", "#999")
        .style("stroke-width", 1) 
        .style("stroke-opacity", 0.6)
        .attr("d", d => {
            let sourceX, sourceY, targetX, targetY;
            
            // Calculate source position (top or bottom)
            if (d.source < halfNodeCount) {
                // Source is on top line
                sourceX = padding + d.source * nodeStep;
                sourceY = topLineY;
            } else {
                // Source is on bottom line
                sourceX = padding + (d.source - halfNodeCount) * nodeStep;
                sourceY = bottomLineY;
            }
            
            // Calculate target position (top or bottom)
            if (d.target < halfNodeCount) {
                // Target is on top line
                targetX = padding + d.target * nodeStep;
                targetY = topLineY;
            } else {
                // Target is on bottom line
                targetX = padding + (d.target - halfNodeCount) * nodeStep;
                targetY = bottomLineY;
            }
            
                // Create different arc paths based on whether nodes are on same or different lines
                if (sourceY === targetY) {
                    // Both nodes on same line
                    const arcHeight = Math.min(Math.abs(sourceX - targetX) * 0.3, height / 5);
                    const arcDirection = sourceY === topLineY ? 1 : -1; // Down for top line, up for bottom (inner side)
                    return `M ${sourceX},${sourceY} Q ${(sourceX + targetX) / 2},${sourceY + arcHeight * arcDirection} ${targetX},${targetY}`;
                } else {
                    // Nodes on different lines (top to bottom) - use a more curved path to keep them inside
                    const midY = (sourceY + targetY) / 2;
                    const controlX1 = sourceX + (targetX - sourceX) / 4;
                    const controlX2 = sourceX + (targetX - sourceX) * 3/4;
                    return `M ${sourceX},${sourceY} C ${controlX1},${midY} ${controlX2},${midY} ${targetX},${targetY}`;
                }
            })
        .on("mouseover", function(event, d) {
            d3.select(this)
                .style("stroke", "#B89491")
                .style("stroke-opacity", 1)
                .style("stroke-width", 1.5);
                
            tooltip.transition()
                .duration(200)
                .style("opacity", 0.9);
            tooltip.html(`Similarity between ${d.sourceId} and ${d.targetId}: ${d.value.toFixed(2)}`)
                .style("left", (event.pageX + 10) + "px")
                .style("top", (event.pageY - 28) + "px");
        })
        .on("mouseout", function(event, d) {
            d3.select(this)
                .style("stroke", "#999")
                .style("stroke-opacity", 0.6)
                .style("stroke-width", 1);
                
            tooltip.transition()
                .duration(500)
                .style("opacity", 0);
        });
    
    // Create node group to ensure nodes are drawn on top of links
    const nodeGroup = container.append("g").attr("class", "nodes");
    
    // Draw nodes with updated positions for U layout
    const nodes = nodeGroup.selectAll("circle")
        .data(graphData.nodes)
        .enter().append("circle")
        .attr("class", "node")
        .attr("r", nodeRadius)
        .attr("cx", (d, i) => {
            if (i < halfNodeCount) {
                // First half goes on top line
                return padding + i * nodeStep;
            } else {
                // Second half goes on bottom line
                return padding + (i - halfNodeCount) * nodeStep;
            }
        })
        .attr("cy", (d, i) => i < halfNodeCount ? topLineY : bottomLineY)
        .style("fill", d => getNodeColor(d))
        .style("stroke", "#fff")
        .style("stroke-width", 2);
    
    // Add event handlers to nodes
    addNodeEventHandlers(nodes, graphData, linkGroup, nodeGroup, nodeRadius);
        
    // Draw labels with different placement for top and bottom nodes
    nodeGroup.selectAll("text")
        .data(graphData.nodes)
        .enter().append("text")
        .attr("class", "node-label")
        .each(function(d, i) {
            // Add labels with the info icon
            addNodeLabel(d3.select(this), d);
        })
        .attr("x", (d, i) => {
            if (i < halfNodeCount) {
                // First half on top
                return padding + i * nodeStep;
            } else {
                // Second half on bottom
                return padding + (i - halfNodeCount) * nodeStep;
            }
        })
        .attr("y", (d, i) => {
            if (i < halfNodeCount) {
                // Labels ABOVE top nodes
                return topLineY - nodeRadius - 15;
            } else {
                // Labels BELOW bottom nodes
                return bottomLineY + nodeRadius + 15;
            }
        })
        .attr("transform", (d, i) => {
            const x = i < halfNodeCount 
                ? padding + i * nodeStep 
                : padding + (i - halfNodeCount) * nodeStep;
                
            const y = i < halfNodeCount 
                ? topLineY - nodeRadius - 15 // Above top line
                : bottomLineY + nodeRadius + 15; // Below bottom line
                
            // Rotate labels differently based on position
            return i < halfNodeCount 
                ? `rotate(270, ${x}, ${y})` // Top line rotation
                : `rotate(270, ${x}, ${y})`; // Bottom line rotation
        })
        .style("font-size", "10px")
        .style("text-anchor", (d, i) => i < halfNodeCount ? "start" : "end")
        .style("dominant-baseline", "middle")
        .style("pointer-events", "all");
        
    // Add click handlers to info icons
    addInfoIconClickHandlers();
}

// Helper function to add node label with info icon
function addNodeLabel(textElement, d) {
    // Get study details from cache
    let study = studyDetailsCache[d.id] || { title: `Study #${d.id}`, id: d.id };
    
    // First tspan for the info icon
    const infoIcon = textElement.append("tspan")
        .attr("class", "info-icon")
        .text("â“˜ ")
        .style("cursor", "pointer")
        .style("font-weight", "bold")
        .style("fill", "#B89491");
    
    // Add the rest of the text in a second tspan
    let labelText = `[${d.id}]`;
    if (study.authors) {
        // Get just the last name if there are multiple authors
        const authorName = study.authors.split(',')[0].trim();
        labelText += ` ${authorName}`;
    }
    if (study.year) {
        labelText += ` (${study.year})`;
    }
    
    textElement.append("tspan")
        .text(labelText);
}

// Helper function to add click handlers to info icons
function addInfoIconClickHandlers() {
    // Add click handlers to info icons after they're in the DOM
    d3.selectAll(".info-icon").on("click", function(event, d) {
        event.stopPropagation();
        // Get the data from the parent
        const parentData = d3.select(this.parentNode).datum();
        // Show study details
        const customEvent = new CustomEvent('showStudyDetailsRequest', {
            detail: { studyId: parentData.id }
        });
        document.dispatchEvent(customEvent);
    });
}

        // Helper function to add event handlers to nodes
        function addNodeEventHandlers(nodes, graphData, linkGroup, nodeGroup, nodeRadius) {
            nodes.on("mouseover", function(event, d) {
                    // Increase node size
                    d3.select(this).attr("r", nodeRadius + 2);
                    
                    // Get node colors
                    const colors = getNodeColor(d);
                    
                    // Handle hover effect based on whether it's multi-value
                    if (Array.isArray(colors)) {
                        // For multi-value nodes, recreate the pattern with larger radius
                        createPatternFill(d3.select(this), d, nodeRadius + 2);
                    } else {
                        // Single color - darken it on hover
                        const baseColor = d3.color(colors);
                        d3.select(this).style("fill", baseColor.darker(0.5));
                    }
                    
                    // Highlight connected links and nodes
                    highlightConnections(d, graphData);
                })
                .on("mouseout", function(event, d) {
                    // Reset node size
                    d3.select(this).attr("r", nodeRadius);
                    
                    // Reset node color/pattern
                    createPatternFill(d3.select(this), d, nodeRadius);
                    
                    // Reset links
                    d3.selectAll(".link")
                        .style("stroke", "#999")
                        .style("stroke-opacity", 0.6)
                        .style("stroke-width", 1);
                    
                    // Reset nodes
                    d3.selectAll(".node").style("opacity", 1);
                    
                    // Reset labels
                    d3.selectAll(".node-label").style("opacity", 1);
                        
                    tooltip.transition()
                        .duration(500)
                        .style("opacity", 0);
                })
                .on("click", function(event, d) {
                    // Find all connections above the threshold for this node
                    const threshold = parseFloat(document.getElementById('thresholdValue').textContent);
                    const connections = [];
                    
                    graphData.links.forEach(link => {
                        if (link.source === d.index) {
                            // This node is the source of the link
                            const targetNode = graphData.nodes[link.target];
                            const targetId = targetNode.id;
                            
                            // Get study details with better handling for IDs that might be strings or numbers
                            let details;
                            if (studyDetailsCache[targetId]) {
                                details = studyDetailsCache[targetId];
                            } else if (studyDetailsCache[targetId.toString()]) {
                                details = studyDetailsCache[targetId.toString()];
                            } else if (studyDetailsCache[Number(targetId)]) {
                                details = studyDetailsCache[Number(targetId)];
                            } else {
                                details = { id: targetId, title: `Study #${targetId}` };
                            }
                            
                            connections.push({
                                studyId: targetId,
                                similarity: link.value,
                                details: details
                            });
                        } else if (link.target === d.index) {
                            // This node is the target of the link
                            const sourceNode = graphData.nodes[link.source];
                            const sourceId = sourceNode.id;
                            
                            // Get study details with better handling for IDs
                            let details;
                            if (studyDetailsCache[sourceId]) {
                                details = studyDetailsCache[sourceId];
                            } else if (studyDetailsCache[sourceId.toString()]) {
                                details = studyDetailsCache[sourceId.toString()];
                            } else if (studyDetailsCache[Number(sourceId)]) {
                                details = studyDetailsCache[Number(sourceId)];
                            } else {
                                details = { id: sourceId, title: `Study #${sourceId}` };
                            }
                            
                            connections.push({
                                studyId: sourceId,
                                similarity: link.value,
                                details: details
                            });
                        }
                    });
                    
                    // Sort connections by similarity value (descending)
                    connections.sort((a, b) => b.similarity - a.similarity);
                    
                    // Get source study details
                    const sourceStudy = studyDetailsCache[d.id] || { id: d.id, title: `Study #${d.id}` };
                    
                    // Create HTML with both selected study at top and connections table
                    let html = `
                    <div class="connections-container">
                        <h5 class="mb-3">Selected Study</h5>
                        <div class="table-responsive mb-4">
                            <table class="table table-striped">
                                <colgroup>
                                    <col style="width: 3%;">  <!-- Info icon column -->
                                    <col style="width: 5%;"> <!-- ID column -->
                                    <col style="width: 17%;"> <!-- Authors column -->
                                    <col style="width: 8%;">  <!-- Year column -->
                                    <col style="width: 15%;"> <!-- Location column -->
                                    <col style="width: 12%;"> <!-- Body Part column -->
                                    <col style="width: 18%;"> <!-- Gesture column -->
                                    <col style="width: 10%;"> <!-- Empty column for alignment -->
                                </colgroup>
                                <thead>
                                    <tr>
                                        <th></th>
                                        <th>ID</th>
                                        <th>Authors</th>
                                        <th>Year</th>
                                        <th>Location</th>
                                        <th>Body Part</th>
                                        <th>Gesture</th>
                                        <th></th> <!-- Empty column for alignment -->
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr class="selected-study-row">
                                        <td><i class="bi bi-info-circle view-study-details" title="View details" data-id="${sourceStudy.id}"></i></td>
                                        <td>${sourceStudy.id}</td>
                                        <td>${sourceStudy.authors || ''}</td>
                                        <td>${sourceStudy.year || ''}</td>
                                        <td>${sourceStudy.Location || sourceStudy[' Location'] || ''}</td>
                                        <td>${sourceStudy['Input Body Part'] || sourceStudy.Input || sourceStudy.inputBodyPart || ''}</td>
                                        <td>${sourceStudy.Gesture || sourceStudy['Gesture Type'] || ''}</td>
                                        <td></td> <!-- Empty cell for alignment -->
                                    </tr>
                                </tbody>
                            </table>
                        </div>

                        <h5 class="mb-3">Study Network</h5>
                        <div class="table-responsive">
                            <table class="table table-striped">
                                <colgroup>
                                    <col style="width: 3%;">  <!-- Info icon column -->
                                    <col style="width: 5%;"> <!-- ID column -->
                                    <col style="width: 17%;"> <!-- Authors column -->
                                    <col style="width: 8%;">  <!-- Year column -->
                                    <col style="width: 15%;"> <!-- Location column -->
                                    <col style="width: 12%;"> <!-- Body Part column -->
                                    <col style="width: 18%;"> <!-- Gesture column -->
                                    <col style="width: 10%;"> <!-- Similarity column -->
                                </colgroup>
                                <thead>
                                    <tr>
                                        <th></th>
                                        <th>ID</th>
                                        <th>Authors</th>
                                        <th>Year</th>
                                        <th>Location</th>
                                        <th>Body Part</th>
                                        <th>Gesture</th>
                                        <th>Similarity</th>
                                    </tr>
                                </thead>
                                <tbody>`;
                    
                    if (connections.length === 0) {
                        html += `
                            <tr>
                                <td colspan="8" class="text-center">No connections found above the current threshold.</td>
                            </tr>
                        </tbody>
                        </table>
                        </div>`;
                    } else {
                        connections.forEach(conn => {
                            const details = conn.details;
                            
                            html += `
                                <tr>
                                    <td><i class="bi bi-info-circle view-study-details" title="View details" data-id="${conn.studyId}"></i></td>
                                    <td>${conn.studyId || ''}</td>
                                    <td>${details.authors || ''}</td>
                                    <td>${details.year || ''}</td>
                                    <td>${details.Location || details[' Location'] || ''}</td>
                                    <td>${details['Input Body Part'] || details.Input || details.inputBodyPart || details.input_body_part || ''}</td>
                                    <td>${details.Gesture || details['Gesture Type'] || ''}</td>
                                    <td><strong>${conn.similarity.toFixed(2)}</strong></td>
                                </tr>
                            `;
                        });
                        
                        html += `
                            </tbody>
                            </table>
                            </div>
                            <p class="text-muted mt-2">Total connections: ${connections.length}</p>
                        </div>`;
                    }
                    
                    // Update the modal content
                    document.getElementById('connectionsContainer').innerHTML = html;
                    
                    // Add event listeners to info icons
                    setTimeout(() => {
                        document.querySelectorAll('.view-study-details').forEach(icon => {
                            icon.addEventListener('click', function() {
                                const studyId = this.getAttribute('data-id');
                                
                                // Close modal before showing study details
                                connectionsModal.hide();
                                
                                // Dispatch custom event that index.html can listen for
                                const event = new CustomEvent('showStudyDetailsRequest', {
                                    detail: { studyId: studyId }
                                });
                                document.dispatchEvent(event);
                            });
                        });
                    }, 100);
                    
                    // Show the modal using Bootstrap
                    connectionsModal.show();

                    handleNodeClick(d);
                });
        }

    
    // Reset the view
    function resetView() {
        if (svg && zoom) {
            // Reset zoom
            svg.transition().duration(750).call(
                zoom.transform,
                d3.zoomIdentity
            );
            
            debug("View reset");
        }
    }
    
    // Download similarity data
    function downloadSimilarityData() {
        try {
            let csvContent = "data:text/csv;charset=utf-8,Study ID";
            
            // Add header row
            studyIds.forEach(id => {
                csvContent += "," + id;
            });
            csvContent += "\n";
            
            // Add data rows
            studyIds.forEach((id, rowIndex) => {
                csvContent += id;
                
                // Ensure the similarityMatrix has data for this row
                if (rowIndex < similarityMatrix.length) {
                    similarityMatrix[rowIndex].forEach(value => {
                        csvContent += "," + value;
                    });
                }
                csvContent += "\n";
            });
            
            // Create download link
            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", "abstract_similarity_matrix.csv");
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            debug("Similarity data downloaded");
        } catch (error) {
            console.error("Error downloading similarity data:", error);
            debug("Error downloading similarity data", error.toString());
            showStatus(`Error downloading similarity data: ${error.message}`, true);
        }
    }
    
    // Filter visualization based on filtered data from main interface
    function filterSimilarityVisualization(filteredData) {
        try {
            // First, reset to original data
            studyIds = [...originalStudyIds];
            similarityMatrix = originalSimilarityMatrix.map(row => [...row]);
            
            // Handle empty filtered data - just clear the visualization
            if (!filteredData || filteredData.length === 0) {
                debug("Empty or no filtered data - clearing visualization");
                
                // Clear existing visualization
                d3.select("#graphContainer").html("");
                
                // Reset SVG to null so we can detect this state
                svg = null;
                
                return;
            }
            
            debug("Filtering visualization", { filteredDataCount: filteredData.length });
            
            // Extract IDs from the filtered data
            const filteredIds = filteredData.map(row => row.ID);
            
            // Filter studyIds and similarityMatrix to only include filtered studies
            const filteredIndices = [];
            const newStudyIds = [];
            
            studyIds.forEach((id, index) => {
                if (filteredIds.includes(id)) {
                    filteredIndices.push(index);
                    newStudyIds.push(id);
                }
            });
            
            debug("Filtered studies", { 
                originalCount: studyIds.length, 
                filteredCount: newStudyIds.length 
            });
            
            // Create a new similarity matrix with only the filtered studies
            const newMatrix = [];
            filteredIndices.forEach(i => {
                if (i >= similarityMatrix.length) return; // Skip if out of bounds
                
                const row = [];
                filteredIndices.forEach(j => {
                    if (j >= similarityMatrix[i].length) return; // Skip if out of bounds
                    row.push(similarityMatrix[i][j]);
                });
                
                if (row.length > 0) {
                    newMatrix.push(row);
                }
            });
            
            // Update global variables
            studyIds = newStudyIds;
            similarityMatrix = newMatrix;
            
            debug("Matrix filtered", { 
                rowCount: similarityMatrix.length,
                studyIdCount: studyIds.length 
            });
            
            // Check if visualization was previously cleared (svg is null)
            if (!svg) {
                // We need to reinitialize the entire visualization
                initializeVisualization();
            } else {
                // Just update the existing visualization with current threshold
                const threshold = parseFloat(document.getElementById('thresholdValue').textContent);
                updateVisualization(threshold);
            }
        } catch (error) {
            console.error("Error filtering visualization:", error);
            debug("Error filtering visualization", error.toString());
            showStatus(`Error filtering visualization: ${error.message}`, true);
        }
    }
    
    // Expose filter function to parent
    window.filterSimilarityVisualization = filterSimilarityVisualization;
</script>


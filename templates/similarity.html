<!-- Include D3.js -->
<script src="https://d3js.org/d3.v7.min.js"></script>

<style>
    #similarityContainer {
        background: #f8f9fa;
        border-radius: 8px;
        padding: 20px;
        box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1);
        margin: 20px 0;
    }
    
    .controls {
        margin-bottom: 20px;
        display: flex;
        align-items: center;
        gap: 15px;
    }
    
    .node {
        cursor: pointer;
    }
    
    .link {
        stroke: #999;
        stroke-opacity: 0.6;
        fill: none;
    }
    
    .node-label {
        font-size: 10px;
        pointer-events: none;
    }
    
    .tooltip {
        position: absolute;
        background: white;
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 8px;
        pointer-events: none;
        box-shadow: 0px 0px 5px rgba(0, 0, 0, 0.2);
        z-index: 1000;
    }
    
    /* Match slider color with site theme */
    .noUi-connect {
        background: #B89491;
    }
    
    /* Error message style */
    .error-message {
        color: #721c24;
        background-color: #f8d7da;
        border-color: #f5c6cb;
        padding: 15px;
        border-radius: 5px;
        margin-bottom: 20px;
    }
    
    /* Loading indicator style */
    .loading-indicator {
        text-align: center;
        padding: 20px;
    }
    
    /* Important: Set minimum dimensions for the graph container */
    #graphContainer {
    width: 100%;
    border: 1px solid #ddd;
    border-radius: 5px;
    overflow: visible;
    margin-bottom: 20px; /* Add some space below the visualization */
    padding: 40px 0px 40px 0px; /* Top, Right, Bottom, Left padding */

}

    .info-icon {
        cursor: pointer;
        transition: transform 0.2s ease, fill 0.2s ease;
    }

    .info-icon:hover {
        fill: #a37c79 !important;
        transform: scale(1.2);
    }

    /* Connections modal styles */
    #connectionsContainer h5 {
        margin-bottom: 15px;
        color: #B89491;
    }

    #connectionsContainer .table {
        font-size: 14px;
    }

    #connectionsContainer .table th {
        background-color: #f8f9fa;
    }

    /* For handling modal interactions */
    .transparent-background-modal {
        opacity: 0 !important;
        pointer-events: none !important;
    }

    /* Add these styles to your existing style section */
    .slider-container {
        padding: 0 20px; /* Adjust the padding as needed */
        margin-top: 5px; /* Add extra space underneath the slider */
        margin-bottom: 30px; /* Add extra space underneath the slider */
    }

    .slider-container .noUi-tooltip {
        bottom: -25px; /* Adjust this value as needed to move the tooltip further down */
        padding: 0px 0px; /* Adjust the padding as needed */
    }

    .noUi-tooltip {
        background: none; /* Remove background */
        border: none; /* Remove border */
        box-shadow: none; /* Remove box shadow */
        color: inherit; /* Inherit text color */
        padding: 0; /* Remove padding */
        bottom: -5px; /* Adjust this value as needed to move the tooltip further down */
    }

</style>

<div id="similarityContainer">
    <div class="controls">
        <div class="slider-container">
            <label for="thresholdSlider" style="margin-bottom: 12px; display: block;">
                <strong>Similarity Threshold (Ïƒ):</strong> <span id="thresholdValue" style="font-weight: bold; color: #B89491;">1.00</span>
                <i class="bi bi-question-circle-fill" title="This visualization shows semantic similarity between paper abstracts. Similarities were calculated using Google Gemini embeddings (gemini-embedding-exp-03-07) with cosine similarity and then z-standardized. Values above 0 indicate above-average similarity (0=mean, 1=one standard deviation above mean). Higher thresholds show only the most similar papers." style="cursor: pointer; margin-left: 5px;"></i>
            </label>           
            <div style="display: flex; align-items: center; width: 400px;">
                <span style="margin-right: 10px; font-size: inherit; color: inherit;" class="noUi-tooltip-style">-3</span>
                <div id="thresholdSlider" class="similarity-slider" style="flex: 1;"></div>
                <span style="margin-left: 10px; font-size: inherit; color: inherit;" class="noUi-tooltip-style">3</span>
            </div>
        </div>
    </div>
    
    <div id="graphContainer"></div>

    <div class="modal fade" id="connectionsModal" tabindex="-1" aria-labelledby="connectionsModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-body">
                    <div id="connectionsContainer">
                        <!-- Connected studies will be populated here -->
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>

</div>

<script>
    // Initialize global variables
    let svg;
    let width, height;
    let zoom;
    let tooltip;
    let studyIds = [];
    let similarityMatrix = [];
    
    // Helper function for debugging
    function debug(message, obj = null) {
    }
    
    // Show status/error message
    function showStatus(message, isError = false) {
        if (isError) {
        console.error(message);
        }
    }
    
    // Add these variables at the top of the script section, with your other global variables
    let originalStudyIds = []; // To store the original study IDs
    let originalSimilarityMatrix = []; // To store the original similarity matrix

    // Modify the processSimilarityData function to cache the original data
    function processSimilarityData() {
        try {
            // Get the raw data from the template
            const rawData = {{ similarity_data | tojson }};
            
            debug("Raw similarity data received", rawData);
            
            if (!rawData || !rawData.study_ids || rawData.study_ids.length === 0) {
                showStatus("No similarity data available. Please check if the data file exists and is properly formatted.", true);
                return false;
            }
            
            // Extract study IDs from the provided data
            studyIds = rawData.study_ids;
            // Cache original study IDs
            originalStudyIds = [...studyIds];
            
            // Store study details for tooltips if available
            studyDetailsCache = rawData.study_details || {};
            
            debug("Extracted study IDs", { count: studyIds.length, first: studyIds[0], last: studyIds[studyIds.length-1] });
            
            if (studyIds.length === 0) {
                showStatus("No study IDs found in the similarity data.", true);
                return false;
            }
            
            // Process the similarity matrix
            similarityMatrix = rawData.matrix || [];
            // Cache original similarity matrix (deep copy)
            originalSimilarityMatrix = similarityMatrix.map(row => [...row]);
            
            debug("Processed similarity matrix", { rows: similarityMatrix.length });
            
            if (similarityMatrix.length === 0) {
                showStatus("Could not process similarity data. Matrix is empty.", true);
                return false;
            }
            
            return true;
        } catch (error) {
            console.error("Error processing similarity data:", error);
            debug("Error processing similarity data", error.toString());
            showStatus(`Error processing similarity data: ${error.message}`, true);
            return false;
        }
    }
    
    // Wait for the page to fully load before initializing
    window.addEventListener('load', function() {
        // Short delay to ensure DOM is fully laid out
        setTimeout(function() {
            const container = document.getElementById('graphContainer');
            
            // Force layout recalculation
            container.style.width = '100%';
            container.style.display = 'block';
            
            // Force the browser to calculate the layout by accessing offsetWidth
            const forceReflow = container.offsetWidth;
            debug("Initial load - forcing container width calculation:", forceReflow);
            
            // Now initialize
            initializeVisualization();
        }, 500); // Longer delay to ensure DOM is fully rendered
    });
    
    // Initialize the visualization when the tab becomes visible
    document.addEventListener('DOMContentLoaded', function() {
        debug("DOM loaded");
        
        // Process data
        if (!processSimilarityData()) {
            return; // Exit if data processing failed
        }
        
        // Create slider
        try {
            const sliderElement = document.getElementById('thresholdSlider');
            
            noUiSlider.create(sliderElement, {
                start: [1], // Default to 1 steddev
                connect: [true, false], // Connect to the left
                range: {
                    'min': -3, // Typically -3 standard deviations
                    'max': 3   // Typically +3 standard deviations
                },
                step: 0.1,
                tooltips: [true], // Show tooltip
                format: {
                    to: function (value) {
                        return value.toFixed(2);
                    },
                    from: function (value) {
                        return parseFloat(value);
                    }
                }
            });
            
            // Update visualization when slider changes
            sliderElement.noUiSlider.on('update', function (values, handle) {
                const threshold = parseFloat(values[handle]);
                document.getElementById('thresholdValue').textContent = threshold.toFixed(2);
                document.getElementById('thresholdValue').classList.add('threshold-value-display');
                
                // Only update visualization if it's been initialized
                if (svg) {
                    updateVisualization(threshold);
                }
            });
        } catch (error) {
            console.error("Error creating slider:", error);
            debug("Error creating slider", error.toString());
            showStatus(`Error initializing controls: ${error.message}`, true);
        }
        
        // Setup tooltip
        tooltip = d3.select("body").append("div")
            .attr("class", "tooltip")
            .style("opacity", 0);
        
        // Add visibility change detection - important for tabs
        document.addEventListener('visibilitychange', handleVisibilityChange);
        
        // Add event listeners for tab switching in the parent page
        document.querySelectorAll('.navbar-item').forEach(navItem => {
            navItem.addEventListener('click', function() {
                // If this is the similarity view tab
                if (this.getAttribute('data-section') === 'similarityView') {
                    // Force layout calculation and initialize visualization
                    setTimeout(function() {
                        const container = document.getElementById('graphContainer');
                        container.style.width = '100%';
                        const forceReflow = container.offsetWidth;
                        debug("Tab switch - forcing container width calculation:", forceReflow);
                        initializeVisualization();
                    }, 300);
                }
            });
        });
        
        // Listen for window resize events with a proper debounce
        window.addEventListener('resize', debounce(function() {
            const container = document.getElementById('graphContainer');
            // Only reinitialize if the graph container is visible
            if (container.offsetParent !== null) {
                debug("Window resize - reinitializing visualization");
                initializeVisualization();
            }
        }, 250));

        // Initialize the connections modal
        connectionsModal = new bootstrap.Modal(document.getElementById('connectionsModal'));
        
        // Handle modal interactions
        document.getElementById('infoModal').addEventListener('show.bs.modal', function() {
            const connectionsModalElement = document.getElementById('connectionsModal');
            if (connectionsModalElement && connectionsModalElement.classList.contains('show')) {
                connectionsModalElement.classList.add('transparent-background-modal');
            }
        });
        
        document.getElementById('infoModal').addEventListener('hidden.bs.modal', function() {
            const connectionsModalElement = document.getElementById('connectionsModal');
            if (connectionsModalElement) {
                connectionsModalElement.classList.remove('transparent-background-modal');
            }
        });
    });
    
    // Also update the handleVisibilityChange function to be more aggressive
    function handleVisibilityChange() {
        if (document.visibilityState === 'visible') {
            // If the document becomes visible and the container is visible
            const similarityView = document.getElementById('similarityView');
            if (similarityView && similarityView.style.display !== 'none') {
                // Force layout calculation and initialize visualization
                setTimeout(function() {
                    const container = document.getElementById('graphContainer');
                    container.style.width = '100%';
                    const forceReflow = container.offsetWidth;
                    debug("Visibility change - forcing container width calculation:", forceReflow);
                    initializeVisualization();
                }, 300);
            }
        }
    }
    
    // Debounce function to limit frequent updates
    function debounce(func, wait) {
        let timeout;
        return function() {
            const context = this;
            const args = arguments;
            clearTimeout(timeout);
            timeout = setTimeout(() => {
                func.apply(context, args);
            }, wait);
        };
    }
    
    // Initialize the visualization container
    function initializeVisualization() {
        debug("Initializing visualization container");
        
        const container = document.getElementById('graphContainer');
        
        // Force the container to be visible and take full width
        container.style.display = 'block';
        container.style.width = '100%';
        
        // Get width from container
        width = container.offsetWidth || 800;
        
        debug("Container width measured", { width });
        
        // Calculate dynamic height based on number of studies
        // Higher threshold for U-shape layout (>50 studies)
        const useULayout = studyIds.length > 50;
        
        // Calculate appropriate height based on number of studies and layout type
        let calculatedHeight;
        if (useULayout) {
            // For U-shape, calculate based on number of studies and spacing
            calculatedHeight = Math.max(500, Math.min(800, studyIds.length * 12));
        } else {
            // For standard layout, less height needed
            calculatedHeight = Math.max(400, Math.min(600, studyIds.length * 8));
        }
        
        // Set height for this visualization
        height = calculatedHeight;
        debug("Dynamic height calculated", { height });
        
        // Clear container
        d3.select("#graphContainer").html("");
        
        // Create SVG with calculated dimensions
        svg = d3.select("#graphContainer").append("svg")
            .attr("width", width)
            .attr("height", height)
            .style("display", "block"); // Ensure block display
            
        // Create a container group
        svg.append("g")
            .attr("class", "viz-layer");
        
        // Initialize with current threshold
        const threshold = parseFloat(document.getElementById('thresholdValue').textContent || "0");
        updateVisualization(threshold);
        
        debug("Visualization initialized with dimensions", { 
            width, 
            height,
            threshold 
        });
    }
    
    // Generate graph data from the similarity matrix
    function generateGraphData(threshold) {
        debug(`Generating graph data with threshold: ${threshold}`);
        
        if (!studyIds.length || !similarityMatrix.length) {
            debug("No data available for graph generation");
            return { nodes: [], links: [] };
        }
        
        const nodes = studyIds.map((id, index) => ({ id, index }));
        const links = [];
        
        let connectionCount = 0;
        
        for (let i = 0; i < studyIds.length; i++) {
            for (let j = i + 1; j < studyIds.length; j++) {
                // Make sure we have data for this cell
                if (i < similarityMatrix.length && j < similarityMatrix[i].length) {
                    const similarity = similarityMatrix[i][j];
                    if (similarity && similarity >= threshold) {
                        links.push({
                            source: i,
                            target: j,
                            sourceId: studyIds[i],
                            targetId: studyIds[j],
                            value: similarity
                        });
                        connectionCount++;
                    }
                }
            }
        }
        
        debug("Graph data generated", { 
            nodeCount: nodes.length,
            linkCount: links.length,
            threshold: threshold,
            connectionCount: connectionCount
        });
        
        return { nodes, links };
    }

    // Line spacing based on screen width
let lineSpacingRatio = 0.25; // Default spacing

// Add a function to determine line spacing based on screen size
function getLineSpacingRatio() {
    // Use window width to determine spacing
    const windowWidth = window.innerWidth;
    
    if (windowWidth < 600) {
        return 0.15; // Very small spacing for small screens
    } else if (windowWidth < 800) {
        return 0.2;  // Small spacing for medium screens
    } else if (windowWidth < 1000) {
        return 0.25; // Medium spacing for larger screens
    } else if (windowWidth < 1200) {
        return 0.3;  // Larger spacing for wide screens
    } else if (windowWidth < 1400) {
        return 0.35;  // Larger spacing for wide screens
    } else if (windowWidth < 1600) {
        return 0.4;  // Larger spacing for wide screens
    } else if (windowWidth < 1800) {
        return 0.45;  // Larger spacing for wide screens
    } else {
        return 0.5; // Maximum spacing for extra wide screens
    }
}
    
    function updateVisualization(threshold) {
    try {
        debug(`Updating visualization with threshold: ${threshold}`);
        
        if (!svg || width === 0) {
            debug("SVG not initialized or has zero width, aborting update");
            return;
        }
        
        // Generate graph data
        const graphData = generateGraphData(threshold);
        
        if (graphData.nodes.length === 0) {
            showStatus("No nodes available to visualize.", true);
            return;
        }
        
        // Clear previous visualization
        d3.select(".viz-layer").html("");
        
        const container = d3.select(".viz-layer");
        
        // Determine if we should use the U-shaped layout (when node count > 50)
        const useULayout = graphData.nodes.length > 50;
        
        // Set layout parameters based on layout type
        const nodeRadius = 8;
        const padding = width * 0.05; // 5% padding on each side
        const lineWidth = Math.max(width - (padding * 2), 1); // Ensure positive width
        
        if (!useULayout) {
            // Standard horizontal line layout
            const lineY = height / 2;
            
            // Draw a horizontal line
            container.append("line")
                .attr("x1", padding)
                .attr("y1", lineY)
                .attr("x2", width - padding)
                .attr("y2", lineY)
                .style("stroke", "#ccc")
                .style("stroke-width", 2);
            
            // Calculate node positions along the line
            const nodeStep = graphData.nodes.length <= 1 ? 0 : lineWidth / (graphData.nodes.length - 1);
            
            // Draw links, nodes, and labels for standard layout
            drawStandardLayout(container, graphData, lineY, nodeStep, padding, nodeRadius);
            
        } else {
            // Adjust the spacing based on available height
            const lineSpacing = getLineSpacingRatio();            const topLineY = height * (0.5 - lineSpacing/2); // Dynamic positioning
            const bottomLineY = height * (0.5 + lineSpacing/2); // Dynamic positioning
            
            const halfNodeCount = Math.ceil(graphData.nodes.length / 2);
            
            // Draw top horizontal line
            container.append("line")
                .attr("x1", padding)
                .attr("y1", topLineY)
                .attr("x2", width - padding)
                .attr("y2", topLineY)
                .style("stroke", "#ccc")
                .style("stroke-width", 2);
                
            // Draw bottom horizontal line
            container.append("line")
                .attr("x1", padding)
                .attr("y1", bottomLineY)
                .attr("x2", width - padding)
                .attr("y2", bottomLineY)
                .style("stroke", "#ccc")
                .style("stroke-width", 2);
                
            // Draw connecting curves on the sides
            /*
            container.append("path")
                .attr("d", `M ${padding},${topLineY} Q ${padding - width * 0.05},${height/2} ${padding},${bottomLineY}`)
                .style("stroke", "#ccc")
                .style("fill", "none")
                .style("stroke-width", 2);
                
            container.append("path")
                .attr("d", `M ${width - padding},${topLineY} Q ${width - padding + width * 0.05},${height/2} ${width - padding},${bottomLineY}`)
                .style("stroke", "#ccc")
                .style("fill", "none")
                .style("stroke-width", 2); */
                
            // Calculate node steps for top and bottom
            const nodeStep = lineWidth / (Math.max(halfNodeCount, 1) - 1);
            
            // Draw links, nodes, and labels for U layout
            drawUShapedLayout(container, graphData, topLineY, bottomLineY, nodeStep, padding, nodeRadius, halfNodeCount);
        }
        
        // Show a message if there are no connections at this threshold
        if (graphData.links.length === 0) {
            container.append("text")
                .attr("x", width / 2)
                .attr("y", height / 2 - 100)
                .style("text-anchor", "middle")
                .style("font-size", "14px")
                .style("fill", "#721c24")
                .text("No connections found at the current threshold. Try lowering the threshold value.");
        }
        
        debug("Visualization updated", {
            nodeCount: graphData.nodes.length,
            linkCount: graphData.links.length,
            threshold: threshold,
            layout: useULayout ? "U-shaped" : "Standard"
        });
    
    } catch (error) {
        console.error("Error updating visualization:", error);
        debug("Error updating visualization", error.toString());
        showStatus(`Error updating visualization: ${error.message}`, true);
    }
}

// Helper function to draw standard horizontal layout
function drawStandardLayout(container, graphData, lineY, nodeStep, padding, nodeRadius) {
    // Create a group for curves (arcs/links) to be drawn below nodes
    const linkGroup = container.append("g").attr("class", "links");
    
    // Draw links
    linkGroup.selectAll("path")
        .data(graphData.links)
        .enter().append("path")
        .attr("class", "link")
        .style("stroke", "#999")
        .style("stroke-width", 1)
        .style("stroke-opacity", 0.6)
        .attr("d", d => {
            const sourceX = padding + d.source * nodeStep;
            const targetX = padding + d.target * nodeStep;
            const arcHeight = Math.min(Math.abs(d.source - d.target) * 15, height / 3);
            
            // Create arc path
            return `M ${sourceX},${lineY} Q ${(sourceX + targetX) / 2},${lineY - arcHeight} ${targetX},${lineY}`;
        })
        .on("mouseover", function(event, d) {
            d3.select(this)
                .style("stroke", "#B89491")
                .style("stroke-opacity", 1)
                .style("stroke-width", 1.5);
                
            tooltip.transition()
                .duration(200)
                .style("opacity", 0.9);
            tooltip.html(`Similarity between ${d.sourceId} and ${d.targetId}: ${d.value.toFixed(2)}`)
                .style("left", (event.pageX + 10) + "px")
                .style("top", (event.pageY - 28) + "px");
        })
        .on("mouseout", function(event, d) {
            d3.select(this)
                .style("stroke", "#999")
                .style("stroke-opacity", 0.6)
                .style("stroke-width", 1);
                
            tooltip.transition()
                .duration(500)
                .style("opacity", 0);
        });
    
    // Create node group to ensure nodes are drawn on top of links
    const nodeGroup = container.append("g").attr("class", "nodes");
    
    // Draw nodes (existing code)
    const nodes = nodeGroup.selectAll("circle")
        .data(graphData.nodes)
        .enter().append("circle")
        .attr("class", "node")
        .attr("r", nodeRadius)
        .attr("cx", (d, i) => padding + i * nodeStep)
        .attr("cy", lineY)
        .style("fill", "#B89491")
        .style("stroke", "#fff")
        .style("stroke-width", 2);
    
    // Add event handlers to nodes (mouseover, mouseout, click)
    addNodeEventHandlers(nodes, graphData, linkGroup, nodeGroup, nodeRadius);
    
    // Draw labels (same as before)
    nodeGroup.selectAll("text")
        .data(graphData.nodes)
        .enter().append("text")
        .attr("class", "node-label")
        .each(function(d, i) {
            // Add labels with the info icon, etc.
            addNodeLabel(d3.select(this), d);
        })
        .attr("x", (d, i) => padding + i * nodeStep)
        .attr("y", lineY + nodeRadius + 15)  // Position text 15px below the node
        .attr("transform", (d, i) => `rotate(270, ${padding + i * nodeStep}, ${lineY + nodeRadius + 15})`)
        .style("font-size", "10px")
        .style("text-anchor", "end")
        .style("dominant-baseline", "middle")
        .style("pointer-events", "all");
    
    // Add click handlers to info icons
    addInfoIconClickHandlers();
}

// Helper function to highlight connections when hovering over a node
function highlightConnections(node, graphData) {
    try {
        // Step 1: Find all connected links and nodes
        const connectedNodeIndices = new Set();
        const connectedLinkIndices = new Set();

        // Add the current node to the set of highlighted nodes
        connectedNodeIndices.add(node.index);
        
        // Find all links and connected nodes
        graphData.links.forEach((link, linkIndex) => {
            // Handle both possible D3 representations (direct indices or objects)
            const sourceIndex = typeof link.source === 'object' ? link.source.index : link.source;
            const targetIndex = typeof link.target === 'object' ? link.target.index : link.target;
            
            // Check if this node is part of the link
            if (sourceIndex === node.index) {
                // This node is the source
                connectedNodeIndices.add(targetIndex);
                connectedLinkIndices.add(linkIndex);
            } else if (targetIndex === node.index) {
                // This node is the target
                connectedNodeIndices.add(sourceIndex);
                connectedLinkIndices.add(linkIndex);
            }
        });

        // Step 2: Apply highlighting to links
        d3.selectAll(".link")
            .style("stroke", (_, i) => connectedLinkIndices.has(i) ? "#B89491" : "#999")
            .style("stroke-opacity", (_, i) => connectedLinkIndices.has(i) ? 1 : 0.3)
            .style("stroke-width", (_, i) => connectedLinkIndices.has(i) ? 1.5 : 1);
        
        // Step 3: Apply highlighting to nodes
        d3.selectAll(".node")
            .style("opacity", (d) => connectedNodeIndices.has(d.index) ? 1 : 0.3);
        
        // Step 4: Apply highlighting to labels
        d3.selectAll(".node-label")
            .style("opacity", (d) => connectedNodeIndices.has(d.index) ? 1 : 0.3);
            
    } catch (error) {
        console.error("Error in highlightConnections:", error);
        // In case of error, reset everything to visible
        d3.selectAll(".link").style("stroke", "#999").style("stroke-opacity", 0.6).style("stroke-width", 1);
        d3.selectAll(".node").style("opacity", 1);
        d3.selectAll(".node-label").style("opacity", 1);
    }
}

// Helper function to check if two nodes are connected - use this with caution as we now use the index-based approach above
function isConnected(a, b, data) {
    if (a.index === b.index) return true;
    
    return data.links.some(l => {
        // Handle both possible representations of source/target
        const sourceIndex = typeof l.source === 'object' ? l.source.index : l.source;
        const targetIndex = typeof l.target === 'object' ? l.target.index : l.target;
        
        return (sourceIndex === a.index && targetIndex === b.index) || 
               (sourceIndex === b.index && targetIndex === a.index);
    });
}


// Helper function to draw U-shaped layout
function drawUShapedLayout(container, graphData, topLineY, bottomLineY, nodeStep, padding, nodeRadius, halfNodeCount) {
    // Create a group for curves (arcs/links) to be drawn below nodes
    const linkGroup = container.append("g").attr("class", "links");
    
    // Draw links with updated path calculations for U layout
    linkGroup.selectAll("path")
        .data(graphData.links)
        .enter().append("path")
        .attr("class", "link")
        .style("stroke", "#999")
        .style("stroke-width", 1) 
        .style("stroke-opacity", 0.6)
        .attr("d", d => {
            let sourceX, sourceY, targetX, targetY;
            
            // Calculate source position (top or bottom)
            if (d.source < halfNodeCount) {
                // Source is on top line
                sourceX = padding + d.source * nodeStep;
                sourceY = topLineY;
            } else {
                // Source is on bottom line
                sourceX = padding + (d.source - halfNodeCount) * nodeStep;
                sourceY = bottomLineY;
            }
            
            // Calculate target position (top or bottom)
            if (d.target < halfNodeCount) {
                // Target is on top line
                targetX = padding + d.target * nodeStep;
                targetY = topLineY;
            } else {
                // Target is on bottom line
                targetX = padding + (d.target - halfNodeCount) * nodeStep;
                targetY = bottomLineY;
            }
            
                // Create different arc paths based on whether nodes are on same or different lines
                if (sourceY === targetY) {
                    // Both nodes on same line
                    const arcHeight = Math.min(Math.abs(sourceX - targetX) * 0.3, height / 5);
                    const arcDirection = sourceY === topLineY ? 1 : -1; // Down for top line, up for bottom (inner side)
                    return `M ${sourceX},${sourceY} Q ${(sourceX + targetX) / 2},${sourceY + arcHeight * arcDirection} ${targetX},${targetY}`;
                } else {
                    // Nodes on different lines (top to bottom) - use a more curved path to keep them inside
                    const midY = (sourceY + targetY) / 2;
                    const controlX1 = sourceX + (targetX - sourceX) / 4;
                    const controlX2 = sourceX + (targetX - sourceX) * 3/4;
                    return `M ${sourceX},${sourceY} C ${controlX1},${midY} ${controlX2},${midY} ${targetX},${targetY}`;
                }
            })
        .on("mouseover", function(event, d) {
            d3.select(this)
                .style("stroke", "#B89491")
                .style("stroke-opacity", 1)
                .style("stroke-width", 1.5);
                
            tooltip.transition()
                .duration(200)
                .style("opacity", 0.9);
            tooltip.html(`Similarity between ${d.sourceId} and ${d.targetId}: ${d.value.toFixed(2)}`)
                .style("left", (event.pageX + 10) + "px")
                .style("top", (event.pageY - 28) + "px");
        })
        .on("mouseout", function(event, d) {
            d3.select(this)
                .style("stroke", "#999")
                .style("stroke-opacity", 0.6)
                .style("stroke-width", 1);
                
            tooltip.transition()
                .duration(500)
                .style("opacity", 0);
        });
    
    // Create node group to ensure nodes are drawn on top of links
    const nodeGroup = container.append("g").attr("class", "nodes");
    
    // Draw nodes with updated positions for U layout
    const nodes = nodeGroup.selectAll("circle")
        .data(graphData.nodes)
        .enter().append("circle")
        .attr("class", "node")
        .attr("r", nodeRadius)
        .attr("cx", (d, i) => {
            if (i < halfNodeCount) {
                // First half goes on top line
                return padding + i * nodeStep;
            } else {
                // Second half goes on bottom line
                return padding + (i - halfNodeCount) * nodeStep;
            }
        })
        .attr("cy", (d, i) => i < halfNodeCount ? topLineY : bottomLineY)
        .style("fill", "#B89491")
        .style("stroke", "#fff")
        .style("stroke-width", 2);
    
    // Add event handlers to nodes
    addNodeEventHandlers(nodes, graphData, linkGroup, nodeGroup, nodeRadius);
        
    // Draw labels with different placement for top and bottom nodes
    nodeGroup.selectAll("text")
        .data(graphData.nodes)
        .enter().append("text")
        .attr("class", "node-label")
        .each(function(d, i) {
            // Add labels with the info icon
            addNodeLabel(d3.select(this), d);
        })
        .attr("x", (d, i) => {
            if (i < halfNodeCount) {
                // First half on top
                return padding + i * nodeStep;
            } else {
                // Second half on bottom
                return padding + (i - halfNodeCount) * nodeStep;
            }
        })
        .attr("y", (d, i) => {
            if (i < halfNodeCount) {
                // Labels ABOVE top nodes
                return topLineY - nodeRadius - 15;
            } else {
                // Labels BELOW bottom nodes
                return bottomLineY + nodeRadius + 15;
            }
        })
        .attr("transform", (d, i) => {
            const x = i < halfNodeCount 
                ? padding + i * nodeStep 
                : padding + (i - halfNodeCount) * nodeStep;
                
            const y = i < halfNodeCount 
                ? topLineY - nodeRadius - 15 // Above top line
                : bottomLineY + nodeRadius + 15; // Below bottom line
                
            // Rotate labels differently based on position
            return i < halfNodeCount 
                ? `rotate(270, ${x}, ${y})` // Top line rotation
                : `rotate(270, ${x}, ${y})`; // Bottom line rotation
        })
        .style("font-size", "10px")
        .style("text-anchor", (d, i) => i < halfNodeCount ? "start" : "end")
        .style("dominant-baseline", "middle")
        .style("pointer-events", "all");
        
    // Add click handlers to info icons
    addInfoIconClickHandlers();
}

// Helper function to add node label with info icon
function addNodeLabel(textElement, d) {
    // Get study details from cache
    let study = studyDetailsCache[d.id] || { title: `Study #${d.id}`, id: d.id };
    
    // First tspan for the info icon
    const infoIcon = textElement.append("tspan")
        .attr("class", "info-icon")
        .text("â“˜ ")
        .style("cursor", "pointer")
        .style("font-weight", "bold")
        .style("fill", "#B89491");
    
    // Add the rest of the text in a second tspan
    let labelText = `[${d.id}]`;
    if (study.authors) {
        // Get just the last name if there are multiple authors
        const authorName = study.authors.split(',')[0].trim();
        labelText += ` ${authorName}`;
    }
    if (study.year) {
        labelText += ` (${study.year})`;
    }
    
    textElement.append("tspan")
        .text(labelText);
}

// Helper function to add click handlers to info icons
function addInfoIconClickHandlers() {
    // Add click handlers to info icons after they're in the DOM
    d3.selectAll(".info-icon").on("click", function(event, d) {
        event.stopPropagation();
        // Get the data from the parent
        const parentData = d3.select(this.parentNode).datum();
        // Show study details
        const customEvent = new CustomEvent('showStudyDetailsRequest', {
            detail: { studyId: parentData.id }
        });
        document.dispatchEvent(customEvent);
    });
}

        // Helper function to add event handlers to nodes
        function addNodeEventHandlers(nodes, graphData, linkGroup, nodeGroup, nodeRadius) {
            nodes.on("mouseover", function(event, d) {
                    d3.select(this)
                        .attr("r", nodeRadius + 2)
                        .style("fill", "#a37c79");
                        
                    // Highlight connected links and nodes using the current graphData
                    highlightConnections(d, graphData);

                })
                .on("mouseout", function() {
                    d3.select(this)
                        .attr("r", nodeRadius)  // Now this will work correctly
                        .style("fill", "#B89491");
                        
                    // Reset links
                    d3.selectAll(".link")
                        .style("stroke", "#999")
                        .style("stroke-opacity", 0.6)
                        .style("stroke-width", 1);
                    
                    // Reset nodes
                    d3.selectAll(".node").style("opacity", 1);
                    
                    // Reset labels
                    d3.selectAll(".node-label").style("opacity", 1);
                        
                    tooltip.transition()
                        .duration(500)
                        .style("opacity", 0);
                })
                .on("click", function(event, d) {
                    // Find all connections above the threshold for this node
                    const threshold = parseFloat(document.getElementById('thresholdValue').textContent);
                    const connections = [];
                    
                    graphData.links.forEach(link => {
                        if (link.source === d.index) {
                            // This node is the source of the link
                            const targetNode = graphData.nodes[link.target];
                            const targetId = targetNode.id;
                            
                            // Get study details with better handling for IDs that might be strings or numbers
                            let details;
                            if (studyDetailsCache[targetId]) {
                                details = studyDetailsCache[targetId];
                            } else if (studyDetailsCache[targetId.toString()]) {
                                details = studyDetailsCache[targetId.toString()];
                            } else if (studyDetailsCache[Number(targetId)]) {
                                details = studyDetailsCache[Number(targetId)];
                            } else {
                                details = { id: targetId, title: `Study #${targetId}` };
                            }
                            
                            connections.push({
                                studyId: targetId,
                                similarity: link.value,
                                details: details
                            });
                        } else if (link.target === d.index) {
                            // This node is the target of the link
                            const sourceNode = graphData.nodes[link.source];
                            const sourceId = sourceNode.id;
                            
                            // Get study details with better handling for IDs
                            let details;
                            if (studyDetailsCache[sourceId]) {
                                details = studyDetailsCache[sourceId];
                            } else if (studyDetailsCache[sourceId.toString()]) {
                                details = studyDetailsCache[sourceId.toString()];
                            } else if (studyDetailsCache[Number(sourceId)]) {
                                details = studyDetailsCache[Number(sourceId)];
                            } else {
                                details = { id: sourceId, title: `Study #${sourceId}` };
                            }
                            
                            connections.push({
                                studyId: sourceId,
                                similarity: link.value,
                                details: details
                            });
                        }
                    });
                    
                    // Sort connections by similarity value (descending)
                    connections.sort((a, b) => b.similarity - a.similarity);
                    
                    // Create a table with the connected studies
                    const sourceStudy = studyDetailsCache[d.id] || { id: d.id, title: `Study #${d.id}` };
                    const tableHTML = `
                        <h5>Connections to ID: ${d.id} with similarity > ${threshold.toFixed(2)}</h5>
                        <table class="table table-striped table-hover">
                            <thead>
                                <tr>
                                    <th></th>
                                    <th>ID</th>
                                    <th>Authors</th>
                                    <th>Year</th>
                                    <th>Location</th>
                                    <th>Input Body Part</th>
                                    <th>Gesture</th>
                                    <th>Similarity</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${connections.map(conn => {
                                    const details = conn.details;
                                    
                                    return `
                                        <tr>
                                            <td><i class="bi bi-info-circle view-details" title="View details" style="cursor: pointer;" data-id="${conn.studyId}"></i></td>
                                            <td>${conn.studyId || ''}</td>
                                            <td>${details.authors || ''}</td>
                                            <td>${details.year || ''}</td>
                                            <td>${details.Location || details[' Location'] || ''}</td>
                                            <td>${details['Input Body Part'] || details.Input || details.inputBodyPart || details.input_body_part || ''}</td>
                                            <td>${details.Gesture || ''}</td>
                                            <td><strong>${conn.similarity.toFixed(2)}</strong></td>
                                        </tr>
                                    `;
                                }).join('')}
                            </tbody>
                        </table>
                    `;
                    
                    // Update the modal content
                    document.getElementById('connectionsContainer').innerHTML = connections.length > 0 ? 
                        tableHTML : "<p>No connections found above the current threshold.</p>";
                    
                    // Add event listeners to info icons
                    setTimeout(() => {
                        document.querySelectorAll('#connectionsContainer .view-details').forEach(icon => {
                            icon.addEventListener('click', function() {
                                const studyId = this.getAttribute('data-id');
                                
                                // Dispatch custom event that index.html can listen for
                                const event = new CustomEvent('showStudyDetailsRequest', {
                                    detail: { studyId: studyId }
                                });
                                document.dispatchEvent(event);
                            });
                        });
                    }, 100);
                    
                    // Show the modal using Bootstrap
                    connectionsModal.show();
                });
        }

    
    // Reset the view
    function resetView() {
        if (svg && zoom) {
            // Reset zoom
            svg.transition().duration(750).call(
                zoom.transform,
                d3.zoomIdentity
            );
            
            debug("View reset");
        }
    }
    
    // Download similarity data
    function downloadSimilarityData() {
        try {
            let csvContent = "data:text/csv;charset=utf-8,Study ID";
            
            // Add header row
            studyIds.forEach(id => {
                csvContent += "," + id;
            });
            csvContent += "\n";
            
            // Add data rows
            studyIds.forEach((id, rowIndex) => {
                csvContent += id;
                
                // Ensure the similarityMatrix has data for this row
                if (rowIndex < similarityMatrix.length) {
                    similarityMatrix[rowIndex].forEach(value => {
                        csvContent += "," + value;
                    });
                }
                csvContent += "\n";
            });
            
            // Create download link
            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", "similarity_matrix.csv");
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            debug("Similarity data downloaded");
        } catch (error) {
            console.error("Error downloading similarity data:", error);
            debug("Error downloading similarity data", error.toString());
            showStatus(`Error downloading similarity data: ${error.message}`, true);
        }
    }
    
    // Filter visualization based on filtered data from main interface
    function filterSimilarityVisualization(filteredData) {
        try {
            // First, reset to original data
            studyIds = [...originalStudyIds];
            similarityMatrix = originalSimilarityMatrix.map(row => [...row]);
            
            if (!filteredData || filteredData.length === 0) {
                debug("No filtered data provided or empty filter - showing all studies");
                // Just use the original data
                const threshold = parseFloat(document.getElementById('thresholdValue').textContent);
                updateVisualization(threshold);
                return;
            }
            
            debug("Filtering visualization", { filteredDataCount: filteredData.length });
            
            // Extract IDs from the filtered data
            const filteredIds = filteredData.map(row => row.ID);
            
            // Filter studyIds and similarityMatrix to only include filtered studies
            const filteredIndices = [];
            const newStudyIds = [];
            
            studyIds.forEach((id, index) => {
                if (filteredIds.includes(id)) {
                    filteredIndices.push(index);
                    newStudyIds.push(id);
                }
            });
            
            debug("Filtered studies", { 
                originalCount: studyIds.length, 
                filteredCount: newStudyIds.length 
            });
            
            // Create a new similarity matrix with only the filtered studies
            const newMatrix = [];
            filteredIndices.forEach(i => {
                if (i >= similarityMatrix.length) return; // Skip if out of bounds
                
                const row = [];
                filteredIndices.forEach(j => {
                    if (j >= similarityMatrix[i].length) return; // Skip if out of bounds
                    row.push(similarityMatrix[i][j]);
                });
                
                if (row.length > 0) {
                    newMatrix.push(row);
                }
            });
            
            // Update global variables
            studyIds = newStudyIds;
            similarityMatrix = newMatrix;
            
            debug("Matrix filtered", { 
                rowCount: similarityMatrix.length,
                studyIdCount: studyIds.length 
            });
            
            // Redraw visualization with current threshold
            const threshold = parseFloat(document.getElementById('thresholdValue').textContent);
            updateVisualization(threshold);
        } catch (error) {
            console.error("Error filtering visualization:", error);
            debug("Error filtering visualization", error.toString());
            showStatus(`Error filtering visualization: ${error.message}`, true);
        }
    }
    
    // Expose filter function to parent
    window.filterSimilarityVisualization = filterSimilarityVisualization;
</script>

